file C:\Users\jlosi\Workspace\electronics-boards-public\power-management\bat\sw\Display\V2\BAT_display_V2.4Dg

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\GOLDELOX.fnc

000001  000001  #platform "GOLDELOX"
000002  000001  #platform "GOLDELOX"
000003  000007  */
000004  000010  */
000005  000011        
000006  000012      // for Goldelox GFX2
000007  000013        
000008  000014      #constant GOLDELOX      1
000009  000014      #constant GOLDELOX      1
000010  000015        
000011  000016      #constant __MAXMEM      255
000012  000016      #constant __MAXMEM      255
000013  000017      #constant __MAXPROG     9216
000014  000017      #constant __MAXPROG     9216
000015  000018        
000016  000019      #constant __PLATFORM    GOLDELOX
000017  000019      #constant __PLATFORM    GOLDELOX
000018  000020        
000019  000021        
000020  000022        
000021  000023        
000022  000024  //==============================================//
000023  000025  // initialization table additional commands     //
000024  000026  //==============================================//
000025  000027  #CONST
000026  000037  #END
000027  000038        
000028  000039  //==============================================//
000029  000040  // putch, putstr, putnum and print redirection  //
000030  000041  // constants                                    //
000031  000042  //==============================================//
000032  000043  #CONST
000033  000048  #END
000034  000049        
000035  000050  //==============================================//
000036  000051  // general number formatting constants          //
000037  000052  // for 'print' and 'putnum'                     //
000038  000053  //==============================================//
000039  000054  #CONST
000040  000186  #END
000041  000187        
000042  000188  // baud divisor rates
000043  000189  #CONST
000044  000211  #END
000045  000212        
000046  000213        
000047  000214        
000048  000219  */
000049  000220        
000050  000221        
000051  000222  //==============================================//
000052  000223  // EVE bios functions                           //
000053  000224  //==============================================//
000054  000225        
000055  000226  func serin(), 1;                                // read a byte from COM0
000056  000227  // Syntax   : serin();
000057  000228  // Usage    : char := serin();
000058  000229  // Notes    : Receives a character from the Serial Port COM0. The transmission format is:
000059  000230  //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000060  000231  //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000061  000232  //          : changed under program control by using the setbaud(...) function.
000062  000233  //          : Returns: -1 if no character is available
000063  000234  //          : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000064  000235  //          : Returns: positive value 0 to 255 for a valid character received
000065  000236        
000066  000237  func putch("char"), 0;                          // write single char to current output device
000067  000238  // Syntax   : putch("char");
000068  000239  // Usage    : putch("A");
000069  000240  // Notes    : Transmits a single byte from the Serial Port COM0. The transmission format is:
000070  000241  //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000071  000242  //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000072  000243  //          : changed under program control by using the setbaud(...) function.
000073  000244  //          : The arguments can be a variable, array element, expression or constant
000074  000245        
000075  000246  func serout("char"), 0;                         // write a byte to COM0
000076  000247  // Syntax   : serout1("char");
000077  000248  // Usage    : serout1(ch);
000078  000249  // Notes    : send character to COM1
000079  000250        
000080  000251  func setbaud("baudnum"), 0;                     // set baud rate of COM0
000081  000252  // Syntax   : setbaud(baud_number);
000082  000253  // Usage    : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000083  000254  // Notes   : specifies the baud rate divisor value or pre-defined constant
000084  000255  //          : The arguments can be a variable, array element, expression or constant
000085  000256  //          : Baud Number Divisor
000086  000257  //          : BAUD_110    27271
000087  000258  //          : BAUD_300    9999
000088  000259  //          : BAUD_600    4999
000089  000260  //          : BAUD_1200   2499
000090  000261  //          : BAUD_2400   1249
000091  000262  //          : BAUD_4800   624
000092  000263  //          : BAUD_9600   312
000093  000264  //          : BAUD_14400  207
000094  000265  //          : BAUD_19200  155
000095  000266  //          : BAUD_31250  95
000096  000267  //          : BAUD_38400  77
000097  000268  //          : BAUD_56000  53
000098  000269  //          : BAUD_57600  51
000099  000270  //          : BAUD_115200 25
000100  000271  //          : BAUD_128000 22
000101  000272  //          : BAUD_256000 11
000102  000273  //          : BAUD_300000 10
000103  000274  //          : BAUD_375000 8
000104  000275  //          : BAUD_500000 6
000105  000276  //          : BAUD_600000 4
000106  000277  //          :
000107  000278  //          : The baud rate is calculated with the following formula:
000108  000279  //          : rate-divisor = (3000000 / baud ) - 1
000109  000280        
000110  000281  func to("device"), 1;                           // output device redirection
000111  000282  // Syntax   : to(outstream);
000112  000283  // Usage    : to(APPEND); putstr("TWO ");
000113  000284  // Notes    : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000114  000285  //          :
000115  000286  //          : to() sends the printed output to destinations other than the screen. Normally, print just
000116  000287  //          : sends its output to the display in TEXT mode which is the default, however, the output from
000117  000288  //          : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000118  000289  //          : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000119  000290  //          : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000120  000291  //          : completed its action. The APPEND argument is used to send the printed output to the same
000121  000292  //          : place as the previous redirection. This is most useful for building string arrays, or adding
000122  000293  //          : sequential data to a media stream.
000123  000294  //          :
000124  000295  //          : Predefined Name   Constant    putch(), putstr(), putnum(), print() redirection
000125  000296  //          : APPEND            0x0000          Output is directed to the same stream that was previously assigned. Output is
000126  000297  //          :                                   appended to user array if previous redirection was to an array.
000127  000298  //          : COM0              0xFF04          Output is redirected to the COM (serial) port.
000128  000299  //          : TEXT              0xFF08          Output is directed to the screen (default).
000129  000300  //          : MDA               0xFF10          Output is directed to the SD or FLASH media.
000130  000301  //          : memory pointer    0x102<0x3FF     Output is redirect to the memory pointer argument.
000131  000302        
000132  000303  func pause("milliseconds"), 0;                  // blocking delay
000133  000304  // Syntax   : pause(milliseconds);
000134  000305  // Usage    : pause(1000);                      //pause for 1 second
000135  000306  // Notes    : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000136  000307        
000137  000308  func putnum("arg1","arg2"), 1;                  // print number to current output device
000138  000309  // Syntax   : putnum(format, value);
000139  000310  // Usage    : var := putnum(HEX, val);
000140  000311  // Notes    : prints a 16bit number in various formats to the current output stream, usually the display.
000141  000312  //          : Format: A constant that specifies the number format
000142  000313  //          : Value : The number to be printed
000143  000314  //          : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )    (    BINARY          )
000144  000315  //          : DEC  DECZ  DECZB      UDEC  UDECZ  UDECZB       HEX  HEXZ  HEXZB      BIN  BINZ    BINZB
000145  000316  //          : DEC1 DEC1Z DEC1ZB     UDEC1 UDEC1Z UDEC1ZB      HEX1 HEX1Z HEX1ZB     BIN1  BIN1Z   BIN1ZB
000146  000317  //          : DEC2 DEC2Z DEC2ZB     UDEC2 UDEC2Z UDEC2ZB      HEX2 HEX2Z HEX1ZB     BIN2  BIN2Z   BIN2ZB
000147  000318  //          : DEC3 DEC3Z DEC3ZB     UDEC3 UDEC3Z UDEC3ZB      HEX3 HEX3Z HEX1ZB     BIN3  BIN3Z   BIN3ZB
000148  000319  //          : DEC4 DEC4Z DEC4ZB     UDEC4 UDEC4Z UDEC4ZB      HEX4 HEX4Z HEX1ZB     BIN4  BIN4Z   BIN4ZB
000149  000320  //          : DEC5 DEC5Z DEC5ZB     UDEC5 UDEC5Z UDEC5ZB                            BIN5  BIN5Z   BIN5ZB
000150  000321  //          :                                                                       BIN6  BIN6Z   BIN6ZB
000151  000322  //          :                                                                       BIN7  BIN7Z   BIN7ZB
000152  000323  //          :                                                                       BIN8  BIN8Z   BIN8ZB
000153  000324  //          :                                                                       BIN9  BIN9Z   BIN9ZB
000154  000325  //          :                                                                       BIN10 BIN10Z  BIN10ZB
000155  000326  //          :                                                                       BIN11 BIN11Z  BIN11ZB
000156  000327  //          :                                                                       BIN12 BIN12Z  BIN12ZB
000157  000328  //          :                                                                       BIN13 BIN13Z  BIN13ZB
000158  000329  //          :                                                                       BIN14 BIN14Z  BIN14ZB
000159  000330  //          :                                                                       BIN15 BIN15Z  BIN15ZB
000160  000331  //          :                                                                       BIN16 BIN16Z  BIN16ZB
000161  000332  //          :
000162  000333  //          : field: Returns the the default width of the numeric field (digit count), usually ignored.
000163  000334  //          : 
000164  000335  //          : bit 15 Leading spaces (1=space before signed number, 0=No space)
000165  000336  //          : bit 14 sign bit (0=signed, 1=unsigned)
000166  000337  //          : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000167  000338  //          : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000168  000339  //          : bits 11-8 Displayed digit quantity
000169  000340  //          : bit 7 String Indicator (1 [CHR], 0 [STR]
000170  000341  //          : bits 6-5 Reserved
000171  000342  //          : bits 4-0 Number base (usually 2,10 or 16)
000172  000343        
000173  000344        
000174  000345  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only)
000175  000346  // Syntax   :  This function is used only by the compiler
000176  000347  // Usage    :   Lookup8 and Lookup16
000177  000348  // Notes    : Reserved for use by compiler only, no use to the programmer
000178  000349        
000179  000350  func putstr("string"), 1;            // print string to current output device
000180  000351  // Syntax   : putstr(pointer);
000181  000352  // Usage    : putstr("HELLO\n");
000182  000353  // Notes    : putstr prints a string to the current output stream, usually the display. The argument can be
000183  000354  //          : a string constant, a pointer to a string, a pointer to an array, or a pointer to a data statement.
000184  000355  //          : The output of putstr can be redirected to the communications port, the media, or memory
000185  000356  //          : using the to(...); function.
000186  000357  //          : A string constant is automatically terminated with a zero.
000187  000358  //          : A string in a data statement is not automatically terminated with a zero.
000188  000359  //          : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000189  000360  //          : element packs 1 or 2 characters.
000190  000361  //          :
000191  000362  //          : Returns the pointer to the item that was printed.
000192  000363        
000193  000364  //==============================================//
000194  000365  // Memory Access Function Prototypes            //
000195  000366  //==============================================//
000196  000367        
000197  000368  func peekB("address"), 1;                       // read a byte from system or user memory
000198  000369  // Syntax   : peekB(address);
000199  000370  // Usage    : myvar := peekB(GFX_XMAX);
000200  000371  // Notes    : This function returns the 8 bit value that is stored at address.
000201  000372  //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte
000202  000373  //          : registers using the pre-defined constants. If peekB(..) or pokeB(..) are used to access other
000203  000374  //          : locations, the address must be doubled to get the correct pointer address.
000204  000375  //          :
000205  000376  //          : Address: The address of a memory byte. The address is usually a pre-defined system
000206  000377  //          : register address constant, The arguments can be a variable, array element, expression or constant.
000207  000378  //          : Return: The 8 bit value stored at address.
000208  000379        
000209  000380  func peekW("address"), 1;                       // read a word from system or user memory
000210  000381  // Syntax   : peekW(address);
000211  000382  // Usage    : myvar := peekW(SYSTEM_TIMER_LO);
000212  000383  // Notes    : This function returns the 16 bit value that is stored at address.
000213  000384  //          : The address of a memory word. The address is usually a pre-defined system register address constant,
000214  000385  //          : The arguments can be a variable, array element, expression or constant.
000215  000386        
000216  000387  func pokeB("address", "bytevalue"), 0;          // write a byte to system or user memory
000217  000388  // Syntax   : pokeB(address, byte_value);
000218  000389  // Usage    : pokeB(CLIP_TOP, 10);
000219  000390  // Notes    : This function writes a 8 bit value to a location specified by address.
000220  000391  //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte registers using the
000221  000392  //          : pre-defined constants. If peekB(..) or pokeB(..) are used to access other locations, the address must be
000222  000393  //          : doubled to get the correct pointer address.
000223  000394  //          :
000224  000395  //          : address: Address of a memory byte. It is usually a pre-defined system register address constant
000225  000396  //          : byte_value: The lower 8 bits of byte_value will be stored at address.
000226  000397  //          : Returns TRUE if poke address was a legal address (usually ignored).
000227  000398        
000228  000399  func pokeW("address", "wordvalue"), 0;          // write a word to system or user memory
000229  000400  // Syntax   : pokeW(address, word_value);
000230  000401  // Usage    : pokeW(TIMER2, 5000);
000231  000402  // Notes    : This function writes a 16 bit value to a location specified by address.
000232  000403  //          :
000233  000404  //          : Address: Address of a memory word. The address is usually a pre-defined system register  address constant
000234  000405  //          : word_value: The 16 bit word_value will be stored at address.
000235  000406  //          : The arguments can be a variable, array element, expression or constant.
000236  000407  //          :
000237  000408  //          : Returns TRUE if poke address was a legal address (usually ignored).
000238  000409        
000239  000410  //==============================================//
000240  000411  // bit manipulators                             //
000241  000412  //==============================================//
000242  000413        
000243  000414  func bits_Set("address","mask"), 0;             // set required bit(s) in memory (16bit operation)
000244  000415  // Syntax   : bits_Set(address, mask);
000245  000416  // Usage    : bits_Set(myval, 0xC0);
000246  000417  // Notes    : This function sets the required bits at address by 'ORing' the mask with the value stored at address.
000247  000418  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will
000248  000419  //          : not work with system register variables
000249  000420  //          :
000250  000421  //          : address :     The address of a user memory location.
000251  000422  //          : mask    :    The 16 bit mask containing bits to be set.
000252  000423  //          : The arguments can be a variable, array element, expression or constant.
000253  000424        
000254  000425  func bits_Clear("address","mask"), 0;           // clear required bit(s) in memory (16bit operation)
000255  000426  // Syntax   : bits_Clear(address, mask);
000256  000427  // Usage    : bits_Clear(myval, 0x3C00);
000257  000428  // Notes    : This function clears the required bits at address by 'ANDing' the inverted mask with the value stored at
000258  000429  //          : address.
000259  000430  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
000260  000431  //          : work with system register variables.
000261  000432  //          :
000262  000433  //          : address:     The address of a user memory location.
000263  000434  //          : mask   :     The 16 bit mask containing bits to be cleared.
000264  000435  //          : The arguments can be a variable, array element, expression or constant.
000265  000436        
000266  000437  func bits_Flip("address","mask"), 0;            // invert required bit(s) in memory (16bit operation)
000267  000438  // Syntax   : bits_Flip(address, mask);
000268  000439  // Usage    : bits_Flip(myval, 0x8802);
000269  000440  // Notes    : This function flips the required bits at address by 'XORing' the mask with the value stored at address.
000270  000441  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
000271  000442  //          : work with system register variables.
000272  000443  //          :
000273  000444  //          : address: The address of a user memory location.
000274  000445  //          : mask   : The 16 bit mask containing bits to be flipped.
000275  000446  //          : The arguments can be a variable, array element, expression or constant.
000276  000447        
000277  000448  func bits_Test("address","mask"), 1;            // test required bit(s) in memory (16bit operation)
000278  000449        
000279  000450  //==============================================//
000280  000451  // Math Functions                               //
000281  000452  //==============================================//
000282  000453        
000283  000454  func ABS("value"), 1;                           // return a positive number
000284  000455  // Syntax   : ABS(value);
000285  000456  // Usage    : var := ABS(arg);
000286  000457  // Notes    : Returns the absolute value of an argument
000287  000458        
000288  000459  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000289  000460  // Syntax   : MIN(value1, value2);
000290  000461  // Usage    : var := MIN(arg1, arg2);
000291  000462  // Notes    : Returns the minimum of 2 arguments
000292  000463        
000293  000464  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000294  000465  // Syntax   : MAX(value1, value2);
000295  000466  // Usage    : var := MAX(arg1, arg2);
000296  000467  // Notes    : Returns the maximum of 2 arguments
000297  000468        
000298  000469  func SWAP("*var", "*var"), 0;                   // swap 2 variables, arguments must point to variables
000299  000470  // Syntax   : SWAP(var1, var2);
000300  000471  // Usage    : SWAP(var1, var2);
000301  000472  // Notes    : Swaps the contents of 2 variables or memory locations
000302  000473        
000303  000474  func SIN("angle"), 1;                           // return SIN of angle
000304  000475  // Syntax   : SIN(angle);
000305  000476  // Usage    : var := SIN(arg);
000306  000477  // Notes    : Returns the sine in radians of an argument in degrees
000307  000478  //          : the returned value range is from 127 to -127. The real
000308  000479  //          : cosine values vary from 1.0 to -1.0 so appropriate
000309  000480  //          : scaling must be done in user code.
000310  000481        
000311  000482  func COS("angle"), 1;                           // return COS of angle
000312  000483  // Syntax   : COS(angle);
000313  000484  // Usage    : var := COS(arg);
000314  000485  // Notes    : Returns the cosine in radians of an argument in degrees
000315  000486  //          : the returned value range is from 127 to -127. The real
000316  000487  //          : cosine values vary from 1.0 to -1.0 so appropriate
000317  000488  //          : scaling must be done in user code.
000318  000489        
000319  000490  func RAND(), 1;                                 // return a pseudo random number
000320  000491  // Syntax   : RAND();
000321  000492  // Usage    : var := RAND();
000322  000493  // Notes    : Returns a random number between 0 and 0xFFFF.
000323  000494  //          : The random number generator must first be seeded
000324  000495  //          : by using the SEED(number) function.
000325  000496        
000326  000497  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000327  000498  // Syntax   : SEED(number);
000328  000499  // Usage    : SEED(arg);
000329  000500  // Notes    : Seeds the random number generator.
000330  000501        
000331  000502  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000332  000503  // Syntax   : OVF();
000333  000504  // Usage    : var:= OVF();
000334  000505  // Notes    :
000335  000506        
000336  000507  func SQRT("number"), 1;                         // return square root of a number
000337  000508  // Syntax   : SQRT(number);
000338  000509  // Usage    : var := SQRT(number);
000339  000510  // Notes    :
000340  000511        
000341  000512  //==============================================//
000342  000513  // Text Control Function                        //
000343  000514  //==============================================//
000344  000515        
000345  000516  func txt_MoveCursor("line", "column"), 0;       // move to required text position (font size related)
000346  000517  // Syntax   : txt_SetCursor(line, column);
000347  000518  // Usage    : txt_SetCursor(arg1, arg2);
000348  000519  // Notes    : Moves the text Cursor to a new screen position set by
000349  000520  //          : line,column parameters.
000350  000521        
000351  000522  func txt_Set("mode", "value"), 0;               // various functions, (see constants below)
000352  000523  // Syntax   : txt_Set(mode, value);
000353  000524  // Usage    : txt_Set(arg1, arg2);
000354  000525  // Notes    : Sets various text related parameters used by other functions
000355  000526  //          :
000356  000527  //          : mode = TEXT_COLOUR (mode 0)
000357  000528  //          : txt_Set(TEXT_COLOUR, value);
000358  000529  //          : value = 0 to 0xFFFF, Black to White
000359  000530  //          : Sets the Text colour for the display
000360  000531  //          : Default = GREEN.
000361  000532  //          :
000362  000533  //          : mode = TEXT_HIGHLIGHT (mode 1)
000363  000534  //          : txt_Set(TEXT_HIGHLIGHT, value);
000364  000535  //          : value = 0 to 0xFFFF, Black to White
000365  000536  //          : Sets the Text background colour for the display. Effective
000366  000537  //          : when text mode is Opaque.
000367  000538  //          : Default = BLACK.
000368  000539  //          :
000369  000540  //          : mode = FONT_ID (mode 2)
000370  000541  //          : txt_Set(FONT_ID, value);
000371  000542  //          : value = FONT1, FONT2 or FONT3 for internal fonts
000372  000543  //          : else this value is the name of a font included
000373  000544  //          : in a users program in a data statement.
000374  000545  //          : Default = FONT SIZE 3.
000375  000546  //          :
000376  000547  //          : mode = TEXT_WIDTH  (mode 3)
000377  000548  //          : txt_Set(TEXT_WIDTH, value);
000378  000549  //          : value = 1 to 16
000379  000550  //          : Sets the Text Width multiplier
000380  000551  //          : text will be printed magnified horizontally
000381  000552  //          : by this factor, Default = 1.
000382  000553  //          :
000383  000554  //          : mode = TEXT_HEIGHT  (mode 4)
000384  000555  //          : txt_Set(TEXT_HEIGHT, value);
000385  000556  //          : value = 1 to 16
000386  000557  //          : Sets the Text Height multiplier
000387  000558  //          : text will be printed magnified vertically
000388  000559  //          : by this factor, Default = 1.
000389  000560  //          :
000390  000561  //          : mode = TEXT_XGAP  (mode 5)
000391  000562  //          : txt_Set(TEXT_XGAP, value);
000392  000563  //          : value = 1 to 32
000393  000564  //          : Sets the horizontal gap between characters
000394  000565  //          : The gap is in pixel units, Default = 0
000395  000566  //          :
000396  000567  //          : mode = TEXT_YGAP  (mode 6)
000397  000568  //          : txt_Set(TEXT_YGAP, value);
000398  000569  //          : value = 1 to 32
000399  000570  //          : Sets the vertical gap below characters
000400  000571  //          : The gap is in pixel units, Default = 0
000401  000572  //          :
000402  000573  //          : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000403  000574  //          : txt_Set(TEXT_PRINTDELAY, value);
000404  000575  //          : value = 0 to 255
000405  000576  //          : Sets the delay time (in ms) during character
000406  000577  //          : printing to give a 'teletype' like effect.
000407  000578  //          : Often used to attract attention to a string
000408  000579  //          : being printed which can often be missed if
000409  000580  //          : just suddenly appearing or changing.
000410  000581  //          : Default = 0 ms.
000411  000582  //          :
000412  000583  //          : mode = TEXT_OPACITY (mode 8)
000413  000584  //          : txt_Set(TEXT_OPACITY, value);
000414  000585  //          : value = TRANSPARENT (0) = Text Trasparent
000415  000586  //          : value = OPAQUE (1) = Text Opaque
000416  000587  //          : Sets the Opacity/Transparency of the text
000417  000588  //          : Default = 0 or TRANSPARENT
000418  000589  //          :
000419  000590  //          : mode = TEXT_BOLD (mode 9)
000420  000591  //          : txt_Set(TEXT_BOLD, value);
000421  000592  //          : value = dont care
000422  000593  //          : Sets Bold Text mode for the next string or char
000423  000594  //          : The feature automatically resets after printing
000424  000595  //          : using putstr or print has completed
000425  000596  //          :
000426  000597  //          : mode = TEXT_ITALIC (mode 10)
000427  000598  //          : txt_Set(TEXT_ITALIC, value);
000428  000599  //          : value = dont care
000429  000600  //          : Sets Italic Text mode for the next string or char
000430  000601  //          : The feature automatically resets after printing
000431  000602  //          : using putstr or print has completed
000432  000603        
000433  000604  //          : mode = TEXT_INVERSE (mode 11)
000434  000605  //          : txt_Set(TEXT_INVERSE, value);
000435  000606  //          : value = dont care
000436  000607  //          : Sets Inverse Text mode for the next string or char
000437  000608  //          : The feature automatically resets after printing
000438  000609  //          : using putstr or print has completed
000439  000610  //          :
000440  000611  //          : mode = TEXT_UNDERLINED (mode 12)
000441  000612  //          : txt_Set(TEXT_UNDERLINED, value);
000442  000613  //          : value = dont care
000443  000614  //          : Sets Underlined Text mode for the next string or char
000444  000615  //          : The feature automatically resets after printing
000445  000616  //          : using putstr or print has completed
000446  000617  //          :
000447  000618  //          : mode = TEXT_ATTRIBUTES (mode 13)
000448  000619  //          : txt_Set(TEXT_ATTRIBUTES, value);
000449  000620  //          : value = bits are defined as:
000450  000621  //          :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000451  000622  //          :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000452  000623  //          :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000453  000624  //          :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000454  000625  //          : Allows a combination of text attributes to be defined together
000455  000626  //          : by 'or'ing the bits together.
000456  000627  //          : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000457  000628  //          : The feature automatically resets after printing
000458  000629  //          : using putstr or print has completed.
000459  000630  //          : Bits 0-3 and 8-15 are reserved for future attributes.
000460  000631        
000461  000632  //==============================================//
000462  000633  // Hardware Function Prototypes                 //
000463  000634  //==============================================//
000464  000635  //        OUTPUT      0
000465  000636  //        INPUT       1
000466  000637  //        ANALOGUE_8  2
000467  000638  //        ANALOGUE_10 3
000468  000639  //        ONEWIRE     4
000469  000640  //        SOUND        5
000470  000641        
000471  000642  func pin_Set("mode", "pin"), 0;                 // set pin to required mode
000472  000643  // Syntax   : pin_Set(mode, pin);
000473  000644  // Usage    : pin_Set(arg1, arg2);
000474  000645  // Notes    : Sets the appropriate pins to Inputs or Outputs
000475  000646  //          :
000476  000647        
000477  000648  func pin_HI("pin"), 0;                          // set pin to logic '1'
000478  000649  // Syntax   : pin_HI(pin);
000479  000650  // Usage    : pin_HI(PIN_0);
000480  000651  //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
000481  000652  //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
000482  000653  // Notes    : Outputs a logic "High" (3.3V) on the appropriate
000483  000654  //          : pin that was previously selected as an Output.
000484  000655        
000485  000656  func pin_LO("pin"), 0;                          // set pin to logic '0'
000486  000657  // Syntax   : pin_LO(pin);
000487  000658  // Usage    : pin_LO(PIN_0);
000488  000659  // Notes    : Outputs a logic "Low" (0V) on the appropriate
000489  000660  //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
000490  000661  //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
000491  000662  //          : pin that was previously  selected as an Output.
000492  000663        
000493  000664  func pin_Read("pin"), 1;                        // read pin, logic or analogue
000494  000665  // Syntax   : pin_Read(PIN_0);
000495  000666  // Usage    : arg1 := pin_Read(arg2);
000496  000667  // Notes    : Reads the logic state or analogue value of the appropriate
000497  000668  //          : pin that was previously selected as an Input or *Analogue.
000498  000669  //          : pin = 0 : Read the state of the RUN pin
000499  000670  //          : Returns a 0 (logic low) or 1 (logic high) or n Analogue.
000500  000671  //          : *NB: Analogue is only available on PIN_1
000501  000672        
000502  000673  func OW_Reset(), 1;                             // issue 1wire reset command
000503  000674  // Syntax   : OW_Reset();
000504  000675  // Usage    : OW_Reset();
000505  000676  // Notes    : Resets  ONEWIRE device
000506  000677  //          : Returns the status, 0 = ACK.
000507  000678  //          :
000508  000679        
000509  000680  func OW_Read(), 1;                              // read data from 1wire bus
000510  000681  // Syntax   : OW_Read();
000511  000682  // Usage    : arg1 := OW_Read();
000512  000683  // Notes    : Reads value of the ONEWIRE pin
000513  000684  //          : that was previously selected for ONEWIRE comms.
000514  000685  //          :
000515  000686  //          : pin = 0 : the next byte from the ONEWIRE bus
000516  000687        
000517  000688  func OW_Read9(), 1;                             // read data from 1wire bus, 9bit mode
000518  000689  // Syntax   : OW_Read9();
000519  000690  // Usage    : OW_Read9();
000520  000691  // Notes    : Reads 9 bit value of the appropriate ONEWIRE pin
000521  000692  //          : that was previously selected for ONEWIRE comms.
000522  000693  //          :
000523  000694  //          : read the 9 bits from the ONEWIRE bus
000524  000695        
000525  000696  func OW_Write("value"), 0;                      // write value to 1wire device
000526  000697  // Syntax   : OW_Write(arg);
000527  000698  // Usage    : OW_Write(arg);
000528  000699  // Notes    : Sends ONEWIRE data on the appropriate
000529  000700  //          : pin that was previously  selected as ONEWIRE comms.
000530  000701  //          :
000531  000702  //          : write arg to the ONEWIRE bus
000532  000703        
000533  000704  func beep("pitch","duration"), 0;               // generate a note on specified port pin
000534  000705  // Syntax   : beep(note, duration);
000535  000706  // Usage    : Beep(20, 50);
000536  000707  // Notes    : Generates a beep for a certain period of time
000537  000708  //          : note    : A value (usually a constant) specifying the frequency of the note.
000538  000709  //          : duration: specifies the time in milliseconds that the note will be played for.
000539  000710  //          : The arguments can be a variable, array element, expression or constant
000540  000711        
000541  000712  func joystick(), 1;                             // read the joystick value
000542  000713  // Syntax   : Joystick();
000543  000714  // Usage    : var := Joystick();
000544  000715  // Notes    : Returned values are:-
000545  000716  //          :    RELEASED 0
000546  000717  //          :    UP       1
000547  000718  //          :    LEFT     2
000548  000719  //          :    DOWN     3
000549  000720  //          :    RIGHT    4
000550  000721  //          :    FIRE     5
000551  000722        
000552  000723  //==============================================//
000553  000724  // Graphics Mode Function Prototypes            //
000554  000725  //==============================================//
000555  000726        
000556  000727  func gfx_Set("mode", "value"), 0;               // set various graphics functions
000557  000728  // Syntax   : gfx_Set(mode, value);
000558  000729  // Usage    : gfx_Set(arg1, arg2);
000559  000730  // Notes    : Sets various graphics parameters used by other functions
000560  000731  //          :
000561  000732  //          : mode = 0 : PenSize
000562  000733  //          : gfx_Set(PEN_SIZE, value);
000563  000734  //          : value = SOLID   : Object Solid
000564  000735  //          : value = OUTLINE : Object Outline
000565  000736  //          : Sets the size of the Pen used by most graphics objects
000566  000737  //          :
000567  000738  //          : mode = 1 : Background Colour
000568  000739  //          : gfx_Set(1, value);
000569  000740  //          : value = 0 to 0xFFFF, Black to White
000570  000741  //          : Sets the Background colour of the screen for gfx_Cls();
000571  000742  //          :
000572  000743  //          : mode = 2 : Object Colour
000573  000744  //          : gfx_Set(OBJECT_COLOUR, value);
000574  000745  //          : value = 0 to 0xFFFF, Black to White
000575  000746  //          : Sets the Object colour used in various functions
000576  000747  //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000577  000748  //          :
000578  000749  //          : mode = 3 : Clipping
000579  000750  //          : gfx_Set(CLIPPING, value);
000580  000751  //          : value = OFF : Clipping disabled
000581  000752  //          : value = ON  : Clipping enabled
000582  000753  //          : Enables/Disables the Clipping feature
000583  000754  //          :
000584  000755  //          : mode = 7 : Set required screen behaviour
000585  000756  //          : gfx_Set(SCREEN_MODE, value);
000586  000757  //          : value = LANDSCAPE         1
000587  000758  //          : value = LANDSCAPE_R     2
000588  000759  //          : value = PORTRAIT         3
000589  000760  //          : value = PORTRAIT_R     4
000590  000761  //          :
000591  000762  //          : mode = 8 : Outline Colour
000592  000763  //          : gfx_Set(OUTLINE_COLOUR, value);
000593  000764  //          : value = 1 to 0xFFFF, OFF to White
000594  000765  //          : Sets the Rectangle or Circle objects outline colour
000595  000766  //          : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000596  000767  //          : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000597  000768  //          :
000598  000769  //          : mode = 9 : Contrast
000599  000770  //          : gfx_Set(CONTRAST, value);
000600  000771  //          : value = 1 to 16, 1=lowest, 16=highest contrast
000601  000772  //          : value = 0 puts display into low power mode.
000602  000773  //          : Sets the contrast
000603  000774  //          : gfx_Set(CONTRAST, OFF); may be used for this
000604  000775        
000605  000776  func gfx_Cls(), 0;                    // clear the screen
000606  000777  // Syntax   : gfx_Cls();
000607  000778  // Usage    : gfx_Cls();
000608  000779  // Notes    : Clears the screen with current background colour
000609  000780        
000610  000781  func gfx_MoveTo("x", "y"), 0;                   // set glb_X1 and glb_Y1 to required co-ordinate
000611  000782  // Syntax   : gfx_MoveTo(x, y);
000612  000783  // Usage    : gfx_MoveTo(arg1, arg2);
000613  000784  // Notes    : Moves the origin to a new x,y position
000614  000785        
000615  000786  func gfx_MoveRel("x", "y"), 0;                  // set glb_X1 and glb_Y1 to new relative offset
000616  000787  // Syntax   : gfx_MoveTo(x, y);
000617  000788  // Usage    : gfx_MoveTo(arg1, arg2);
000618  000789  // Notes    : Moves the origin relative to  x,y and sets a new position
000619  000790        
000620  000791  func gfx_LineTo("x1", "y1"), 0;                 // draw line from current origin to new point
000621  000792  // Syntax   : gfx_LineTo(x1, y1);
000622  000793  // Usage    : gfx_LineTo(arg1, arg2);
000623  000794  // Notes    : Draws a Line from the origin x,y to x1,y1.
000624  000795  //          : The new origin is then set to x1, y1. Line colour needs
000625  000796  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000626  000797        
000627  000798  func gfx_LineRel("x1", "y1"), 0;                // draw line from current origin to new relative offset
000628  000799  // Syntax   : gfx_LineRel(x1, y1);
000629  000800  // Usage    : gfx_LineRel(arg1, arg2);
000630  000801  // Notes    : Draws a Line from the origin x,y to x1,y1.
000631  000802  //          : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000632  000803  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000633  000804        
000634  000805  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;  // draw line, can be patterned
000635  000806  // Syntax   : gfx_Line(x1, y1, x2, y2, colr);
000636  000807  // Usage    : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000637  000808  // Notes    : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000638  000809        
000639  000810  func gfx_Hline("y", "x1", "x2", "colr"), 1;     // draw Hline, can be patterned
000640  000811  // Syntax   : gfx_Hline(y, x1, x2, colr);
000641  000812  // Usage    : var := gfx_Hline(arg1, arg2, arg3, arg4);
000642  000813  // Notes    : Plots a coloured Horizontal Line y pixels away from origin
000643  000814  //          : starting from x1 to x2
000644  000815  //          : Returns number of pixels plotted
000645  000816        
000646  000817  func gfx_Vline("x", "y1", "y2", "colr"), 1;    // draw Vline, can be patterned
000647  000818  // Syntax   : gfx_Vline(x, y1, y2, colr);
000648  000819  // Usage    : var := gfx_Vline(arg1, arg2, arg3, arg4);
000649  000820  // Notes    : Plots a coloured Vertical Line x pixels away from origin
000650  000821  //          : starting from y1 to y2
000651  000822  //          : Returns number of pixels plotted
000652  000823        
000653  000824  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;  // draw open rectangle,line can be patterned
000654  000825  // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
000655  000826  // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000656  000827  // Notes    : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000657  000828  //          : bottom corner (x2,y2) on the screen.
000658  000829        
000659  000830  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;  // draw filled rectangle
000660  000831  // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
000661  000832  // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000662  000833  // Notes    : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000663  000834  //          : bottom corner (x2,y2) on the screen.
000664  000835        
000665  000836  func gfx_Circle("x", "y", "rad", "colr"), 0;  // draw open circle
000666  000837  // Syntax   : gfx_Circle(x, y, rad, colr);
000667  000838  // Usage    : gfx_Circle(arg1, arg2, arg3, arg4);
000668  000839  // Notes    : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000669  000840        
000670  000841  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;        // draw filled circle
000671  000842  // Syntax   : gfx_CircleFilled(x, y, rad, colr);
000672  000843  // Usage    : gfx_CircleFilled(arg1, arg2, arg3, arg4);
000673  000844  // Notes    : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000674  000845        
000675  000846  func gfx_PutPixel("x", "y", "colr"), 0;      // set point at x y
000676  000847  // Syntax   : gfx_PutPixel(x, y, colr);
000677  000848  // Usage    : gfx_PutPixel(arg1, arg2, arg3);
000678  000849  // Notes    : Plots a coloured pixel on the screen at x,y location
000679  000850        
000680  000851  func gfx_GetPixel("x", "y"), 1;             // read colour at point x y
000681  000852  // Syntax   : gfx_GetPixel(x, y);
000682  000853  // Usage    : var := gfx_GetPixel(arg1, arg2);
000683  000854  // Notes    : Reads and returns the colour value of a pixel at location x,y
000684  000855        
000685  000856  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000686  000857  // Syntax   : gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000687  000858  // Usage    : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000688  000859  // Notes    : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000689  000860  //          : Vertices must be specified in an anti-clockwise fashion
000690  000861        
000691  000862  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;  // set result holders for orbit command
000692  000863  // Syntax   : gfx_OrbitInit(&x_orb, &y_orb);
000693  000864  // Usage    : gfx_OrbitInit(&arg1, &arg2);
000694  000865  // Notes    : Sets up the Orbit function parameters.
000695  000866  //          : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000696  000867  //          : variables that get updated after calling gfx_Orbit(,,) function.
000697  000868  //          : The coordiantaes are calculated relative to the origin
000698  000869  //          : obtained by using the gfx_MoveTo(x, y) function.
000699  000870        
000700  000871  func gfx_Orbit("angle", "distance"), 0;     // calculate point at angle, distance
000701  000872  // Syntax   : gfx_Orbit(angle, distance);
000702  000873  // Usage    : gfx_Orbit(arg1, arg2);
000703  000874  // Notes    : The Orbit function calcualtes the x, y coordinates of a distant point whose
000704  000875  //          : only known parameters are the angle and the distance from the current origin.
000705  000876        
000706  000877  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;  // draw a polyline from a table of points
000707  000878  // Syntax   : gfx_Polyline(n, &vx, &vy, colr);
000708  000879  // Usage    : gfx_Polyline(arg1, x[array], y[array], arg2);
000709  000880  // Notes    : This function is very similar to the Polygon function
000710  000881  //          : with the exception of the 1st and the last vertices not joined.
000711  000882        
000712  000883  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;   // draw a polygon from a table of points
000713  000884  // Syntax   : gfx_Polygon(n, &vx, &vy, colr);
000714  000885  // Usage    : gfx_Polygon(arg1, x[array], y[array], arg2);
000715  000886  // Notes    : Plots a coloured Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000716  000887  //          : Vertices must be minimum of 3 and can be specified in any fashion
000717  000888        
000718  000889  func gfx_Dot(), 0;                              // set point at glb_X glb_Y, default colour
000719  000890  // Syntax   : gfx_Dot();
000720  000891  // Usage    : gfx_Dot();
000721  000892  // Notes    : Places a coloured dot at the origin
000722  000893        
000723  000894  func gfx_Bullet("r"), 0;                        // draw circle at glb_X glb_Y, default colour
000724  000895  // Syntax   : gfx_Dot(r);
000725  000896  // Usage    : gfx_Dot(radius);
000726  000897  // Notes    : Places a coloured circle at the origin with radius r
000727  000898  //          : colour needs to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000728  000899  //          : and the PenSize setting determines if circle is solid or outline.
000729  000900        
000730  000901  func gfx_IncX(), 1;                            // increment global origin glb_X, returning new value
000731  000902  // Syntax   : gfx_IncX();
000732  000903  // Usage    : var := gfx_IncX();
000733  000904  // Notes    : Increments the x coordinate of the origin
000734  000905  // Notes    : Returns new value
000735  000906        
000736  000907  func gfx_IncY(), 1;                            // increment global origin glb_Y, returning new value
000737  000908  // Syntax   : gfx_IncY();
000738  000909  // Usage    : var := gfx_IncY();
000739  000910  // Notes    : Increments the y coordinate of the origin
000740  000911  // Notes    : Returns new value
000741  000912        
000742  000913  func gfx_BoxTo("x1", "y1"), 0;                 // draw rectangle from current origin to x1 y1
000743  000914  // Syntax   : gfx_BoxTo(x1, y1);
000744  000915  // Usage    : gfx_BoxTo(arg1, arg2);
000745  000916  // Notes    : Draws a Rectangle from the origin x,y to x1,y1.
000746  000917  //          : The new origin is then set to x1,y1. Rectangle colour needs
000747  000918  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000748  000919  //          : and the PenSize setting determines if Box is solid or outline.
000749  000920        
000750  000921  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;  // set the cipping area
000751  000922  // Syntax   : gfx_ClipWindow(x1, y1, x2, y2);
000752  000923  // Usage    : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000753  000924  // Notes    : Specifies a clipping window region on the screen such that any objects
000754  000925  //          : and text placed onto the screen will be clipped and displayed only
000755  000926  //          : within that region. For the clipping window to take effect, "Clipping"
000756  000927  //          : must be enabled seperately using the gfx_Set(CLIPPING, ON) function.
000757  000928        
000758  000929  func gfx_ChangeColour("oldcolr", "newcolr"), 0;  // change pixel colour in clipping area
000759  000930  // Syntax   : gfx_ChangeColour(oldcolr, newcolr);
000760  000931  // Usage    : gfx_ChangeColour(0xFF00, 0xFFFF);
000761  000932  // Notes    : Changes the pixel colour in the currently focussed clipping region
000762  000933        
000763  000934  func gfx_FocusWindow(), 1;                      // focus on the clipping area, returning the pixel count
000764  000935  // Syntax   : gfx_FocusWindow();
000765  000936  // Usage    : var := gfx_FocusWindow();
000766  000937  // Notes    : sets the focus on the clipping region and returns number of pixels in the region.
000767  000938        
000768  000939  func gfx_SetClipRegion(), 1;                    // set clipping area to the most recent extents
000769  000940  // Syntax   : gfx_SetClipRegion();
000770  000941  // Usage    : VAR := gfx_SetClipRegion();
000771  000942  // Notes    :
000772  000943        
000773  000944  //==============================================//
000774  000945  // uSD/FLASH Function Prototypes                //
000775  000946  //==============================================//
000776  000947        
000777  000948  func media_Video("x", "y"), 0;                  // display movie at position x y
000778  000949  // Syntax   : media_Video(x, y);
000779  000950  // Usage    : media_Video(arg1, arg2);
000780  000951  // Notes    : Play a Video/Animation clip from the uSD card at screen location
000781  000952  //          : specified by x,y (top left corner). The location of the clip in the
000782  000953  //          : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000783  000954        
000784  000955  func media_VideoFrame("x", "y","framenumber"), 0;// display required frame from a movie at x y
000785  000956  // Syntax   : media_VideoFrame(Frame_number);
000786  000957  // Usage    : arg1 := media_VideoFrame();
000787  000958  // Notes    : After a pointer to a valid video has been set with media_SetSector,
000788  000959  //          : calling this function shows each fram sequentially, returning
000789  000960  //          : the number of frames remaining. The position of the image is
000790  000961  //          : at the current origin as set with gfx_MoveTo(...);
000791  000962        
000792  000963  func media_SetAdd("HiWord", "LoWord"), 0;       // set stream byte address
000793  000964  // Syntax   : media_SetAdd(AddHiWord, AddLoWord);
000794  000965  // Usage    : media_SetAdd(arg1, arg2);
000795  000966  // Notes    : Set uSD internal Address pointer for bytewise access
000796  000967        
000797  000968  func media_SetSector("HiWord", "LoWord"), 0;    // set stream sector address
000798  000969  // Syntax   : media_SetSector(SectHiWord, SectLoWord);
000799  000970  // Usage    : media_SetSector(arg1, arg2);
000800  000971  // Notes    : Set uSD internal Sector pointer for sector block access
000801  000972        
000802  000973  func media_ReadByte(), 1;                       // read a byte at the current stream position
000803  000974  // Syntax   : media_RdByte();
000804  000975  // Usage    : var := media_RdByte();
000805  000976  // Notes    : Reads and Returns a single byte of data from the
000806  000977  //          : uSD card pointed to by the internal Address pointer.
000807  000978  //          : After the read the Address pointer is automatically
000808  000979  //          : incremented by 1.
000809  000980        
000810  000981  func media_ReadWord(), 1;                       // read a word at the current stream position
000811  000982  // Syntax   : media_ReadWord();
000812  000983  // Usage    : var := media_ReadWord();
000813  000984  // Notes    : Reads and Returns a single word of data from the
000814  000985  //          : uSD card pointed to by the internal Address pointer.
000815  000986  //          : After the read the Address pointer is automatically
000816  000987  //          : incremented by 1.
000817  000988        
000818  000989  func media_WriteByte("byte"), 1;                // write a byte to the current stream position
000819  000990  // Syntax   : media_WriteByte(arg1);
000820  000991  // Usage    : var := media_WriteByte(arg1);
000821  000992  // Notes    : Writes and Returns xxxxx
000822  000993  //          : After the write the Address pointer is automatically
000823  000994  //          : incremented by 1.
000824  000995        
000825  000996  func media_WriteWord("word"), 1;                // write a word to the current stream position
000826  000997  // Syntax   : media_WriteWord(arg1);
000827  000998  // Usage    : var := media_WriteWord(arg1);
000828  000999  // Notes    : Writes and Returns xxxxx
000829  001000  //          : After the write the Address pointer is automatically
000830  001001  //          : incremented by 1.
000831  001002        
000832  001003  func media_Image("x", "y"), 0;                  // display image at position x y
000833  001004  // Syntax   : media_Image(x, y);
000834  001005  // Usage    : media_Image(arg1, arg2);
000835  001006  // Notes    : Display an image from the uSD card at screen location
000836  001007  //          : specified by x,y (top left corner). The location of the
000837  001008  //          : Image in the uSD card must be specified by
000838  001009  //          : media_setSector(Image_Sector_Add) function.
000839  001010        
000840  001011  func media_Flush(), 1;                          // after writing to media, flush the sector and write
000841  001012  // Syntax   : media_Flush();
000842  001013  // Usage    : var := media_Flush();
000843  001014  // Notes    : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
000844  001015  //          : is being written is correctly stored back to the media else write operations may be unpredictable.
000845  001016        
000846  001017  func media_Init(), 1;                           // initialize uSD card
000847  001018  // Usage    : media_Init();
000848  001019  // Notes    : Initialise uSD CARD
000849  001020  //          : Response: 0 = No Card
000850  001021  //          :           1 = Card Initialised
000851  001022        
000852  001023        
000853  001024  //==============================================//
000854  001025  // RTTTL Specific Function Prototypes           //
000855  001026  //==============================================//
000856  001027        
000857  001028  func tune_Play("TunePtr"), 0;                   // play a RTTTL tune string
000858  001029  // Syntax   : tune_Play(TunePtr);
000859  001030  // Usage    : tune_Play("...notes...");
000860  001031  // Notes    : Play a tune string from a data statement or a direct string
000861  001032        
000862  001033  func tune_Pause(), 0;                           // pause RTTTL (sound continues at current note)
000863  001034  // Syntax   : tune_Pause();
000864  001035  // Usage    : tune_Pause();
000865  001036  // Notes    : Suspends any current tune from playing until a tune_Continue(),
000866  001037  //          : tune_Stop(); or a new tune_Play("...") function. The oscillator
000867  001038  //          : is not stopped
000868  001039        
000869  001040  func tune_Continue(), 0;                        // continue RTTTL
000870  001041  // Syntax   : tune_Continue();
000871  001042  // Usage    : tune_Continue();
000872  001043  // Notes    : Continues playing any previously stopped or paused tune
000873  001044        
000874  001045  func tune_Stop(), 0;                            // stop playing RTTTL tune, sound muted
000875  001046  // Syntax   : tune_Stop();
000876  001047  // Usage    : tune_Stop();
000877  001048  // Notes    : Pauses a tune and silences the oscillator until a tune_Continue(),
000878  001049  //          : tune_Stop(), tune_End or a new tune_Play("..."); function
000879  001050        
000880  001051  func tune_End(), 0;                             // cancel a RTTTL tune
000881  001052  // Syntax   : tune_End();
000882  001053  // Usage    : tune_End();
000883  001054  // Notes    : Ends any current tune and resets the tune interpreter
000884  001055        
000885  001056  func tune_Playing(), 1;                         // pol RTTTL player to see if a tune is playing
000886  001057  // Syntax   : tune_Playing();
000887  001058  // Usage    : var := tune_Playing();
000888  001059  // Notes    : returns 1 if tune is playing, 0 if no tune is playing.
000889  001060        
000890  001061  //==============================================//
000891  001062  // Communications Function Prototypes           //
000892  001063  //==============================================//
000893  001064  func com_AutoBaud("timeout"), 1;                // wait for timeout millisconds, retur baud rate if "U" received
000894  001065  // Syntax   : com_AutoBaud(timeout);
000895  001066  // Usage    : arg := com_AutoBaud(500);
000896  001067  //          : enter auto baud mode for "time" milliseconds, wait for "U"
000897  001068  //          : If timeout occurs, a 0 is returned, else the baud rate
000898  001069  //          : divisor calculated is returned for verification if required.
000899  001070        
000900  001071  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
000901  001072  // Syntax   : com_Init(buffer, bufsize, qualifier);
000902  001073  // Usage1   : com_Init(mybuf, 20, 0);
000903  001074  // Usage2   : com_Init(mybuf, 20, ':');
000904  001075  // Notes    : initialize a serial capture buffer for the comms input
000905  001076  //          : The program must declare a var array as a circular buffer.
000906  001077  //          : Usage1 declares a circular buffer which will continually
000907  001078  //          : buffer characters.
000908  001079  //          : Usage2 must receive ':' before any characters will
000909  001080  //          : accumulate in the buffer.
000910  001081        
000911  001082  func com_Reset(), 0;                            // reset the ring buffer
000912  001083  // Syntax   : com_Reset();
000913  001084  // Usage    : com_Reset();
000914  001085  // Notes    : reset comms to default polled mode
000915  001086        
000916  001087  func com_Count(), 1;                            // return count of characters in ring buffer
000917  001088  // Syntax   : com_Count();
000918  001089  // Usage    : arg := com_Count();
000919  001090  // Notes    : return count of buffered characters in buffer attachment
000920  001091        
000921  001092  func com_Full(), 1;                             // return TRUE if com buffer filled to capcity
000922  001093  // Syntax   : com_Full();
000923  001094  // Usage    : if (com_Full() ,,,, go read buffer;
000924  001095  // Notes    : return true if buffer full (not necessarily an error if buffer is sized to a packet size)
000925  001096        
000926  001097  func com_Error(), 1;                            // return TRUE if a comms error occurred
000927  001098  // Usage    : if (com_Error() ) ...... take recovery action;
000928  001099  // Notes    : Returns 1 if any low level communications error occurred, else returns 0.
000929  001100        
000930  001101  func com_Sync(), 1;                             // returns TRUE if qualifier has been received
000931  001102  // Syntax   : com_Sync();
000932  001103  // Usage    : var := com_Sync();
000933  001104  // Notes    : return true if sync character has been received in com_Init("...") mode
000934  001105        
000935  001106  func com_Checksum(), 1;                         // returns checksum if employed. 0 = OK
000936  001107  // Syntax   : com_Checksum();
000937  001108  // Usage    : if(!com_Checksum()); processMyPacket();
000938  001109  // Notes    : Transparent to normal operation, a check summing system is operating. If the host sends one extra
000939  001110  //          : character as part of the packet (usually added at the end of the packet) which is the negated value of the
000940  001111  //          : addition of all the previous characters in the packet. Once the com_Full() function reports a buffer full
000941  001112  //          : situation (ie the packet is fully received) , the checksum can be read, and should read zero if the packet
000942  001113  //          : is not corrupted.
000943  001114  //          :
000944  001115  //          : Returns 0 if checksum has been computed correctly.
000945  001116        
000946  001117  func com_PacketSize(), 1;                       // returns size of the comms buffer for packet mode
000947  001118  // Syntax   : com_PacketSize();
000948  001119  // Usage    : If (!com_Count()); print("Waiting....");
000949  001120  // Notes    : com_PacketSize() will indicate how large the packet is ONLY after the packet reception has started.
000950  001121  //          : Although it is usually not required to know the packet size until the packet has actually been read, if it
000951  001122  //          : is a requirement, the count is available as soon as com_Count() becomes non zero. If not in variable
000952  001123  //          : packet length mode, com_PacketSize() just returns the size of the specified buffer.
000953  001124  //          :
000954  001125  //          : Returns the size of a packet if in variable packet length mode, or just the size of the serial buffer if
000955  001126  //          : not variable packet length mode.
000956  001127        
000957  001128  //==============================================//
000958  001129  // Display Initialization                       //
000959  001130  // (for GOLDELOX-GFX2 with external display)    //
000960  001131  //==============================================//
000961  001132        
000962  001133  func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
000963  001134  // Syntax   : disp_Init(initTable, stateMachine);
000964  001135  // Usage    : disp_Init(INIT_tbl, GRAM_sm);
000965  001136  // Notes    : The GOLDELOX-GFX2 needs to be aware of all the display registers and how to access them.
000966  001137  //          : The initialisation and the state machine tables are necessary to achieve this. Refer to the individual
000967  001138  //          : display data sheet available from the display manufacturer.
000968  001139  //          : For hardware platform modules such as uOLED-96-G1(GFX), uOLED-128-G1(GFX), etc the disp_Init(,,) is not
000969  001140  //          : needed. The modules are factory set-up with their display specific configurations.
000970  001141  //          :
000971  001142  //          : initTable   : A reference to the device initialisation table which is stored as a data statement.
000972  001143  //          : stateMachine: A reference to the device state machine table which is stored as a data statement.
000973  001144  //          :
000974  001145        
000975  001146  //==============================================//
000976  001147  // Display Access                               //
000977  001148  //==============================================//
000978  001149        
000979  001150  func disp_WriteByte("value"), 0;                // write a data byte to the display
000980  001151  // Syntax: disp_WriteByte(value);
000981  001152  // Usage    : on a SD1339 display driver IC
000982  001153  //          : #constant DRAW_CIRCLE 0x86
000983  001154  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
000984  001155  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
000985  001156  //          :     disp_WriteByte(x);                // set x1
000986  001157  //          :     disp_WriteByte(y);                // set y1
000987  001158  //          :     disp_WriteByte(r);                // set x2
000988  001159  //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
000989  001160  //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
000990  001161  //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
000991  001162  //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
000992  001163  //          : endfunc
000993  001164  // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
000994  001165  //          : sheets for the display for more information. This function is used to extend the capabilities of the user
000995  001166  //          : code to gain access to the the display hardware.
000996  001167  //          :
000997  001168  //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
000998  001169  //          : the display.
000999  001170        
001000  001171  func disp_WriteControl("value"), 0;             // write a control byte to the display
001001  001172  // Syntax: disp_WriteControl("value");
001002  001173  // Usage    : on a SD1339 display driver IC
001003  001174  //          : #constant DRAW_CIRCLE 0x86
001004  001175  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
001005  001176  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
001006  001177  //          :     disp_WriteByte(x);                // set x1
001007  001178  //          :     disp_WriteByte(y);                // set y1
001008  001179  //          :     disp_WriteByte(r);                // set x2
001009  001180  //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
001010  001181  //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
001011  001182  //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
001012  001183  //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
001013  001184  //          : endfunc
001014  001185  // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
001015  001186  //          : sheets for the display for more information. This function is used to extend the capabilities of the user
001016  001187  //          : code to gain access to the the display hardware.
001017  001188  //          : value Specifies the value to be written to the display control register. Only the lower 8 bits are sent to
001018  001189  //          : the display.
001019  001190        
001020  001191  func disp_WriteWord("value"), 0;                // write a word (HI:LO format) to the display
001021  001192  // Syntax   : disp_WriteWord(value);
001022  001193  // Usage    : on a SD1339 display driver IC
001023  001194  //          : #constant DRAW_CIRCLE 0x86
001024  001195  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
001025  001196  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
001026  001197  //          :     disp_WriteByte(x);                // set x1
001027  001198  //          :     disp_WriteByte(y);                // set y1
001028  001199  //          :     disp_WriteByte(r);                // set x2
001029  001200  //          :     disp_WriteWord(linecolour);       // set outline colour
001030  001201  //          :     disp_WriteWord(fillcolour);       // set fill colour
001031  001202  //          : endfunc
001032  001203  // Notes    : Sends a 16 bit value to the display bus. Since the GOLDELOX-GFX2 display data bus is 8bits wide, the HIGH
001033  001204  //          : byte is sent first followed by the LOW byte. Refer to individual data sheets for the display for more
001034  001205  //          : information. This function is used to extend the capabilities of the user code to gain access to the the
001035  001206  //          : display hardware.
001036  001207  //          :
001037  001208  //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
001038  001209  //          : the display.
001039  001210        
001040  001211  func disp_ReadByte(), 1;                        // read a byte from the display
001041  001212  // Syntax   : disp_ReadByte();
001042  001213  // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
001043  001214  //          : gfx_FocusWindow(); // focus GRAM
001044  001215  //          : pixel_Hi:= dispReadByte(); // read hi byte of first pixel
001045  001216  //          : pixel_Lo:= dispReadByte(); // read lo byte of first pixel
001046  001217  // Notes    : Reads a byte from the display after an internal register or GRAM access has been set.
001047  001218  //          : value Returns the 8bit data that was read from the display. Only the lower 8bits are valid.
001048  001219        
001049  001220  func disp_ReadWord(), 1;                        // read a word from the display (HI:LO format)
001050  001221  // Syntax   : disp_ReadWord();
001051  001222  // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
001052  001223  //          : gfx_FocusWindow(); // focus GRAM
001053  001224  //          : pixel := dispReadWord(); // read 1st pixel, HI:LO order
001054  001225  // Notes    : Reads a 16bit word from the display after an internal register or GRAM access has been set.
001055  001226  //          : Returns the 16bit data that was read from the display.
001056  001227        
001057  001228  func disp_BlitPixelFill("colr","count"), 0;      // write "count" pixels to the display (8 or 16 bit)
001058  001229  // Syntax   : disp_BlitPixelFill(colour, count);
001059  001230  // Usage    : gfx_ClipWindow(40,40,79,79); // select a block on the display
001060  001231  //          : count := gfx_FocusWindow(); // focus GRAM
001061  001232  //          : myvar:=dispBlitPixelFill(RED,count); // paint the area red
001062  001233  // Notes    : Fills a preselected GRAM screen area with the specified colour. colour Specifies the colour for the
001063  001234  //          : fill. count Specifies the number of pixels to fill.
001064  001235  //          : The arguments can be a variable, array element, expression or constant
001065  001236        
001066  001237  func disp_BlitPixelsToMedia(), 1;               // write current clip window to the media (8 or 16 bit), return pixel count
001067  001238  // Syntax   : disp_BlitPixelsToMedia();
001068  001239  // Usage    : media_SetSector(0x0020,0x0000); // we're going to write here
001069  001240  //          : n:=disp_BlitPixelsToMedia (); // save it to sector
001070  001241  // Notes    : Write the selected GRAM area to the media at the current media address. Needs a uSD card.
001071  001242  //          : Returns the number of pixels that were written to the media.
001072  001243        
001073  001244  func disp_BlitPixelsFromCOM("mode"), 0;         // write pixels from the serial port to the currnetly focused GRAM area (8 or 16 bit)
001074  001245  // Syntax   : disp_BlitPixelFromCOM(mode);
001075  001246  // Usage    : gfx_ClipWindow(40,40,59,59); // writing to a 40x40 block on the display.
001076  001247  //          : gfx_FocusWindow(); // NB first focus is just so we can get pixel count of area.
001077  001248  //          : print("Filling ",*IMG_PIXEL_COUNT," pixels");
001078  001249  //          : gfx_FocusWindow();
001079  001250  //          : disp_BlitPixelsFromCOM(0); // get pixels from serial port,
001080  001251  //          : while(*IMG_PIXEL_COUNT); // wait till all the pixels come in
001081  001252  // Notes    : Fills a preselected GRAM screen area with the specified colour.
001082  001253  //          : mode = 0 : specifies 16 bit pixels
001083  001254  //          : mode = pointer : specifies pointer to 16 element colour lookup table for each 4bit pixel value
001084  001255  //          : The arguments can be a variable, array element, expression or constant
001085  001256        
001086  001257  func disp_BlitPixelsToCOM(), 1;                 // write current clip window to the com port (8 or 16 bit), return pixel count
001087  001258  // Syntax   : disp_BlitPixelsToCOM();
001088  001259  // Usage    : gfx_ClipWindow(40,40,44,44);  // within a small block on the display
001089  001260  //          : pixels:=gfx_FocusWindow(); // focus GRAM and get pixel count of area
001090  001261  //          : disp_BlitPixelFill(0x4142, pixels);// fill the area using ASCII values so we can read easily
001091  001262  //          : disp_BlitPixelsToCOM(); // write the pixels to the COM port
001092  001263  // Notes    : Write the selected GRAM area to the serial (COM) port..
001093  001264  //          : Returns the number of pixels that were written to the serial port.
001094  001265        
001095  001266  func disp_BlitPixelsFromMedia("count"), 0;      // write "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
001096  001267  // Syntax   : disp_BlitPixelsFromMedia(pixelcount);
001097  001268  // Usage    : media_SetAdd(0x0002, 0x3C00); // point to required area of an image
001098  001269  //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
001099  001270  // Notes    : Read the required number of pixels consecutively from the current media stream and write
001100  001271  //          : them to the current display GRAM address. For 8bit colour mode, each pixel comprises a single 8bit value.
001101  001272  //          : For 16bit colour, each pixel is composed of 2 bytes, the high order byte is read first, the low order bye
001102  001273  //          : is read next.
001103  001274  //          : pixelcount Specifying the number of pixels to be consecutively read from the media stream.
001104  001275  //          : The arguments can be a variable, array element, expression or constant
001105  001276        
001106  001277  func disp_SkipPixelsFromMedia("count"), 0;      // skip "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
001107  001278  // Syntax   : disp_SkipPixelsFromMedia("count");
001108  001279  // Usage    : disp_SkipPixelsFromMedia(20); // skip the next 20 pixels from media
001109  001280  //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
001110  001281  // Notes    : Skip the required number of pixels consecutively from the current media stream, discarding them. For 8bit
001111  001282  //          : colour mode, each pixel comprises a single 8bit value. For 16bit colour, each pixel is composed of 2
001112  001283  //          : bytes, the high order byte is read first, the low order bye is read next.
001113  001284  //          :
001114  001285  //          : pixelcount Specifying the number of pixels to be consecutively skipped from the media stream.
001115  001286  //          : The arguments can be a variable, array element, expression or constant
001116  001287        
001117  001288  //==============================================//
001118  001289  // unadorned SPI functions                      //
001119  001290  //==============================================//
001120  001291        
001121  001292  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001122  001293  // Syntax   : spi_Init(speed, input_mode, output_mode);
001123  001294  // Usage    : spi_Init(speed,ip_mode,op_mode);
001124  001295  // Notes    : Sets up the GOLDELOX-GFX2 SPI port to communicate with SPI devices.
001125  001296  //          : Note: The SPI functions in this section are not necessary when using the memory card or serial flash chips
001126  001297  //          : interfaced to the SPI port. The SPI functions in this section are relevant to those devices other than the
001127  001298  //          : memory card and the serial flash chip used for media access.
001128  001299  //          : speed         : Sets the speed of the SPI port.
001129  001300  //          : input_mode    : Sets the input mode of the SPI port.
001130  001301  //          : output_mode   : Sets the output mode of the SPI port. See diagram below.
001131  001302  //          : The arguments can be a variable, array element, expression or constant
001132  001303        
001133  001304  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001134  001305  // Syntax   : spi_Read();
001135  001306  // Usage    : var := spi_Read();
001136  001307  // Notes    : This function allows a raw unadorned byte read from the SPI device.
001137  001308  //          : Note: The Chip Select line (SDCS) is lowered automatically.
001138  001309  //          : Returns a single data byte from the SPI device.
001139  001310        
001140  001311  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001141  001312  // Syntax   : spi_Write("byte");
001142  001313  // Usage    : spi_Write(byte);
001143  001314  // Notes    : This function allows a raw unadorned byte write to the SPI device.
001144  001315  //          : Note: The Chip Select line (SDCS) is lowered automatically.
001145  001316  //          : byte specifies the data byte to be sent to the SPI device.
001146  001317        
001147  001318  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001148  001319  // Syntax   : spi_Disable();
001149  001320  // Usage    : spi_Disable();
001150  001321  // Notes    : This function raises the Chip Select (SDCS) line of the SPI device, disabling it from further activity.
001151  001322  //          : The CS line will be automatically lowered next time the SPI functions spi_Read() or spi_Write(...) are
001152  001323  //          : used, and also by action of any of the media_ functions.
001153  001324        
001154  001325        
001155  001326  //==============================================//
001156  001327  // flash device specific functions              //
001157  001328  //==============================================//
001158  001329        
001159  001330  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001160  001331  // Syntax   : flash_SIG();
001161  001332  // Usage    : var := flash_SIG();
001162  001333  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001163  001334  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
001164  001335  //          : devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit
001165  001336  //          : (2M x 8) Serial Flash Memory.
001166  001337  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
001167  001338  //          : byte is ignored.
001168  001339        
001169  001340  func flash_ID(), 1;                             // read ID code from FLASH device
001170  001341  // Syntax   : flash_ID();
001171  001342  // Usage    : var := flash_ID();
001172  001343  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001173  001344  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
001174  001345  //          : The only devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to
001175  001346  //          : 32Mbit (2M x 8) Serial Flash Memory.
001176  001347  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
001177  001348  //          : contains capacity. Refer to the device data sheet for further information.
001178  001349        
001179  001350  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001180  001351  // Syntax   : flash_BulkErase();
001181  001352  // Usage    : flash_BulkErase();
001182  001353  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001183  001354  //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
001184  001355  //          : supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8)
001185  001356  //          : Serial Flash Memory.
001186  001357  //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
001187  001358  //          : seconds depending on the size of the flash device.
001188  001359        
001189  001360  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001190  001361  // Syntax   : flash_BlockErase("block")
001191  001362  // Usage    : var := flash_BlockErase(block_num)
001192  001363  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001193  001364  //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
001194  001365  //          : far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8) Serial Flash
001195  001366  //          : Memory.
001196  001367  //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
001197  001368  //          : blockAddress The address of the 64k FLASH block to be erased.
001198  001369  //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
001199  001370  //          : can take up to 3 milliseconds.
001200  001371        
001201  001372  //==============================================//
001202  001373  // user stack operations                        //
001203  001374  //==============================================//
001204  001375        
001205  001376  func setsp("offset"), 0;                        // set the user stack pointer (same as pokeW(USR_SP, n); )
001206  001377  // Syntax   : setsp(index);
001207  001378  // Usage    : setsp(0); // reset the stack pointer
001208  001379  // Notes    : The users stack pointer is zeroed at power up, but it is sometimes necessary to alter the stack pointer
001209  001380  //          : for various reasons, such as running multiple concurrent stacks, or resetting to a known position as part
001210  001381  //          : of an error recovery process.
001211  001382  //          : index: This argument is used to set the users SP to the required position. The stack pointer is set to
001212  001383  //          : zero during power-up initialisation.
001213  001384        
001214  001385  func getsp(), 1;                                // return the current stack pointer (same as peekW(USR_SP); )
001215  001386  // Usage    : push(1234);
001216  001387  //          : print(getsp()); // print the stack index
001217  001388  // Notes    : This function returns the current stack index into the stack array. If the index is zero, there are no
001218  001389  //          : items on the stack.
001219  001390  //          : index: The current stack index.
001220  001391        
001221  001392  func pop(), 1;                                  // pop var off stack
001222  001393  // Syntax   : pop();
001223  001394  // Usage    : push(100);
001224  001395  //          : push(200);
001225  001396  //          : print(pop()+ pop());
001226  001397  // Notes    : This function returns the value at the current stack pointer index. The stack pointer is then
001227  001398  //          : decremented, so it now points to the item below. If the stack pointer is zero, (ie a pop was performed on
001228  001399  //          : an empty stack) the function returns 0 and the stack pointer is not altered (ie it remains at 0).
001229  001400  //          : Returns the value at current stack pointer index.
001230  001401        
001231  001402  func drop("count"), 0;                          // drop n vars off stack
001232  001403  // Syntax   : drop(count);
001233  001404  // Usage    : myvar := 10;
001234  001405  //          : push(1234);
001235  001406  //          : push(5678);
001236  001407  //          : push(myvar);
001237  001408  //          : drop(2);
001238  001409  // Notes    : Decrements the user stack pointer determined by the value n. If n exceeds the stack index, the stack
001239  001410  //          : pointer is zeroed.
001240  001411  //          : count Specifies the number of items to be dropped from the stack.
001241  001412        
001242  001413  func push("item"), 1;                           // push value to stack
001243  001414  // Syntax   : push(val);
001244  001415  // Usage    : Myvar := 10;
001245  001416  //          : push(1234);
001246  001417  //          : push(5678);
001247  001418  //          : push(myvar);
001248  001419  // Notes    : Increment the user stack pointer first and then places the item into the user stack array at the current
001249  001420  //          : position. The stack pointer is now pointing to this new item.
001250  001421  //          : val: Argument to be pushed to the user stack.
001251  001422        
001252  001423  func call(), 1;                                 // exec a function using stacked frame (frame is dropped)
001253  001424  // Syntax   : call()
001254  001425  // Usage    : push(10);
001255  001426  //          : push(10);
001256  001427  //          : push(50);
001257  001428  //          : push(50);
001258  001429  //          : push(0xFFFF);
001259  001430  //          : push(gfx_RectangleFilled); // push the function call address
001260  001431  //          : push(5); // push the argument count
001261  001432  //          : //~~~~~~~
001262  001433  //          : call();
001263  001434  // Notes    : Calls the specified function, the arguments to the called function are from the stack. The stacked
001264  001435  //          : parameters are consumed and the stack pointer is altered to match the number of arguments that were
001265  001436  //          : consumed.
001266  001437  //          : value: If the called function returns a value then it is available.
001267  001438        
001268  001439  func exec("func","argcnt"), 1;                  // exec a function using stacked parameters (parameters remain)
001269  001440  // Syntax   : exec("func","argcnt");
001270  001441  // Usage    : Push(50); // set some arbitrary values on the stack
001271  001442  //          : push(50);
001272  001443  //          : push(10);
001273  001444  //          : push(YELLOW);
001274  001445  //          : //~~~~~~~
001275  001446  //          : exec(gfx_Circle,4); // exec the circle function using the stacked parameters
001276  001447  // Notes    : Calls the specified function, passing the arguments to the called function from the stack. The stack and
001277  001448  //          : stack pointer are not altered.
001278  001449  //          : functionPtr A pointer to a function which will utilise the stacked arguments. argCount The count of
001279  001450  //          : arguments on the stack that are to be passed to the function call.
001280  001451  //          : The arguments can be a variable, array element, expression or constant.
001281  001452        
001282  001453  //==============================================//
001283  001454  // size modifier                                //
001284  001455  //==============================================//
001285  001456        
001286  001457  func iterator("offset"), 0;                     // set the iterator size for ++/-- (same as pokeW(INCVAL, n);
001287  001458  // Syntax   : iterator("offset");
001288  001459  // Usage    : iterator(arg);
001289  001460  // Notes    :
001290  001461        
001291  001462  //==============================================//
001292  001463  // string and character size function           //
001293  001464  //==============================================//
001294  001465        
001295  001466  func strlen("pointer"), 1;                      // return length of a string in character units
001296  001467  // Syntax   : strlen("pointer");
001297  001468  // Usage    : var := strlen(Str);
001298  001469  // Notes    : strlen returns the length of a zero terminated string in character units. Note that any string constants
001299  001470  //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
001300  001471  //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
001301  001472  //          : function to work correctly.
001302  001473  //          : pointer: The pointer to a zero (0x00) terminated string.
001303  001474  //          : Returns the length of a string in character units.
001304  001475        
001305  001476  func charwidth("char"), 1;                          // return width of a character in pixel units
001306  001477  // Syntax   : charwidth("char");
001307  001478  // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
001308  001479  //          : w := charwidth('W');  // get a characters width
001309  001480  // Notes    : charwidth is used to calculate the width in pixel units for a string, based on the currently selected
001310  001481  //          : font. The font can be proportional or mono-spaced. If the total width of the string exceeds 255 pixel
001311  001482  //          : units, the function will return the 'wrapped' (modulo 8) value.
001312  001483  //          : char: The ascii character for the width calculation.
001313  001484  //          : Returns the width of a single character in pixel units.
001314  001485        
001315  001486  func charheight("char"), 1;                         // return height of a character in pixel units
001316  001487  // Syntax   : charheight("char");
001317  001488  // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
001318  001489  //          : w := charheight('W'); // get a characters width
001319  001490  // Notes    : charheight is used to calculate the height in pixel units for a string, based on the currently selected
001320  001491  //          : font. The font can be proportional or mono-spaced.
001321  001492  //          : char: The ascii character for the height calculation.
001322  001493  //          : Returns the height of a single character in pixel units.
001323  001494        
001324  001495  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001325  001496  // Syntax   : strwidth("pointer");
001326  001497  // Usage    : var := strwidth(Str);
001327  001498  // Notes    : strwidth returns the width of a zero terminated string in pixel units. Note that any string constants
001328  001499  //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
001329  001500  //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
001330  001501  //          : function to work correctly.
001331  001502  //          : pointer: The pointer to a zero (0x00) terminated string.
001332  001503  //          : Returns the width of a string in pixel units.
001333  001504        
001334  001505  func strheight(), 1;                            // return height of a string in pixel units
001335  001506  // Syntax   : strheight(Str);
001336  001507  // Usage    : var := strheight();
001337  001508  // Notes    : strheight returns the height of a zero terminated string in pixel units. The strwidth function must be
001338  001509  //          : called first which makes available width and height. Note that any string constants declared in your
001339  001510  //          : program are automatically terminated with a zero as an end marker by the compiler. Any string that you
001340  001511  //          : create in the DATA section or MEM section must have a zero added as a terminator for this function to work
001341  001512  //          : correctly.
001342  001513  //          : Returns the height of a string in pixel units.
001343  001514        
001344  001515  //==============================================//
001345  001516  // extended functions                           //
001346  001517  //==============================================//
001347  001518        
001348  001519  func EVE_SP(), 1;                               // current EVE stack pointer
001349  001520  // Syntax   : EVE_SP();
001350  001521  // Usage    : var := EVE_SP();
001351  001522  // Notes    : returns the EVE stack pointer, useful for fault finding
001352  001523  //          : and checking for stack limits. Eve stack is 0x300 to 0x3FF
001353  001524  //          : Your application should not take stack above 0x3C0 to allow
001354  001525  //          : room for internal use.
001355  001526        
001356  001527        
001357  001528  //==============================================//
001358  001529  // Single parameter short-cuts                  //
001359  001530  // for the txt_Set functions                    //
001360  001531  //==============================================//
001361  001532        
001362  001533  func txt_FGcolour("colour"), 0;                 // 0  text foreground colour
001363  001534  // Syntax   : txt_FGcolour("colour")
001364  001535  // Usage    : txt_FGcolour(colr);
001365  001536  // Notes    : Change text foreground color
001366  001537        
001367  001538  func txt_BGcolour("colour"), 0;                 // 1  text background colour
001368  001539  // Syntax   : txt_BGcolour("colour");
001369  001540  // Usage    : txt_BGcolour(colr);
001370  001541  // Notes    : Change text background color
001371  001542        
001372  001543  func txt_FontID("id"), 0;                       // 2  text font ID (0 = system font)
001373  001544  // Syntax   : txt_FontID("id");
001374  001545  // Usage    : txt_FontID(font_num);
001375  001546  // Notes    : Set font type
001376  001547        
001377  001548  func txt_Width("multiplier"), 0;                // 3  text width multiplier
001378  001549  // Syntax   : txt_Width("multiplier");
001379  001550  // Usage    : txt_Width(arg);
001380  001551  // Notes    : Multiply the text width by x times.
001381  001552        
001382  001553  func txt_Height("multiplier"), 0;               // 4  text height multiplier
001383  001554  // Syntax   : txt_Height("multiplier");
001384  001555  // Usage    : txt_Height(arg);
001385  001556  // Notes    :  Multiply the text height by x times.
001386  001557        
001387  001558  func txt_Xgap("pixelcount"), 0;                 // 5  text gap between characters
001388  001559  // Syntax   : txt_Xgap("pixelcount");
001389  001560  // Usage    : txt_Xgap(arg);
001390  001561  // Notes    : Set gap between two consecutive characters
001391  001562        
001392  001563  func txt_Ygap("pixelcount"), 0;                 // 6  text gap between lines
001393  001564  // Syntax   : txt_Ygap("pixelcount");
001394  001565  // Usage    : txt_Ygap(arg);
001395  001566  // Notes    : Set gap between two consecutive rows of characters
001396  001567        
001397  001568  func txt_Delay("millisecs"), 0;                 // 7  text printing delay factor
001398  001569  // Syntax   : txt_Delay("millisecs");
001399  001570  // Usage    : txt_Delay(arg);
001400  001571  // Notes    : Text printing delay
001401  001572        
001402  001573  func txt_Opacity("mode"), 0;                    // 8  text OPAQUE or TRANSPARENT
001403  001574  // Syntax   : txt_Opacity("mode");
001404  001575  // Usage    : txt_Opacity(arg);
001405  001576  // Notes    : Set text to be opaque or transparent
001406  001577  //          : 0 for opaque
001407  001578  //          : 1 for transparent
001408  001579        
001409  001580  func txt_Bold("mode"), 0;                       // 9  text bold ON/OFF
001410  001581  // Syntax   : txt_Bold("mode");
001411  001582  // Usage    : txt_Bold(arg);
001412  001583  // Notes    : Set bold text on or off
001413  001584  //          : 0 bold off
001414  001585  //          : 1 bold on
001415  001586        
001416  001587  func txt_Italic("mode"), 0;                     // 10 text italic ON/OFF
001417  001588  // Syntax   : txt_Italic("mode");
001418  001589  // Usage    : txt_Italic(arg);
001419  001590  // Notes    : Set Itallic text on or off
001420  001591  //          : 0 Itallic off
001421  001592  //          : 1 Itallic on
001422  001593        
001423  001594  func txt_Inverse("mode"), 0;                    // 11 text inverse ON/OFF
001424  001595  // Syntax   : txt_Inverse("mode");
001425  001596  // Usage    : txt_Inverse(arg);
001426  001597  // Notes    : Set inverse text on or off
001427  001598  //          : 0 Inverse off
001428  001599  //          : 1 Inverse on
001429  001600        
001430  001601  func txt_Underline("mode"), 0;                  // 12 text underline ON/OFF
001431  001602  // Syntax   : txt_Underline("mode");
001432  001603  // Usage    : txt_Underline(arg);
001433  001604  // Notes    : Set Underline text on or off
001434  001605  //          : 0 Underlining off
001435  001606  //          : 1 Underlining on
001436  001607        
001437  001608  func txt_Attributes("value"), 0;                // 13 text combined bold|italic|inverse|underline
001438  001609  // Syntax   : txt_Attributes("value");
001439  001610  // Usage    : txt_Attributes(arg);
001440  001611  // Notes    : text combined bold|italic|inverse|underline, enabled or disabled simultaneously
001441  001612  //          : 0 : bold|italic|inverse|underline disabled
001442  001613        
001443  001614  func _1E(), 0;                                  // 14 text reserved
001444  001615  func _1F(), 0;                                  // 15 text reserved
001445  001616        
001446  001617  //==============================================//
001447  001618  // Single parameter short-cuts                  //
001448  001619  // for the gfx_Set functions                    //
001449  001620  //==============================================//
001450  001621        
001451  001622  func gfx_PenSize("mode"), 0;                    // 0  graphics pen size, SOLD or OUTLINE
001452  001623  // Syntax   : gfx_PenSize("mode");
001453  001624  // Usage    : gfx_PenSize("mode");
001454  001625  // Notes    : Set pen size.
001455  001626  //          : 0 Solid object
001456  001627  //          : 1 Outline object
001457  001628        
001458  001629  func gfx_BGcolour("colour"), 0;                 // 1  graphics background colour
001459  001630  // Syntax   : gfx_BGcolour("colour");
001460  001631  // Usage    : gfx_BGcolour(colr");
001461  001632  // Notes    : Sets background color of the screen
001462  001633  //          : value = 0 to 0xFFFF, Black to White
001463  001634        
001464  001635  func gfx_ObjectColour("colour"), 0;             // 2  graphics object colour
001465  001636  // Syntax   : gfx_ObjectColour("colour");
001466  001637  // Usage    : gfx_ObjectColour(colr);
001467  001638  // Notes    : Sets the Object colour used in various functions
001468  001639  //          : value = 0 to 0xFFFF, Black to White
001469  001640  //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001470  001641        
001471  001642  func gfx_Clipping("mode"), 0;                   // 3  graphics clipping ON/OFF
001472  001643  // Syntax   : gfx_Clipping("mode");
001473  001644  // Usage    : gfx_Clipping("mode");
001474  001645  // Notes    : Set clipping mode
001475  001646  //          : 0 : Clipping disabled
001476  001647  //          : 1 : Clipping enabled
001477  001648        
001478  001649  func gfx_TranparentColour("colour"), 0;         // 4  graphics image transparent mask colour
001479  001650  // Syntax   : gfx_TranparentColour("colour");
001480  001651  // Usage    : gfx_TranparentColour("colr");
001481  001652  // Notes    : Sets Bitmap, Image or Animation Transparency Colour
001482  001653  //          : value = 0 to 0xFFFF Black to White
001483  001654        
001484  001655  func gfx_Tranparency("mode"), 0;                // 5  graphics image transparent mode ON/OFF
001485  001656  // Syntax   : gfx_Tranparency("mode");
001486  001657  // Usage    : gfx_Tranparency("mode");
001487  001658  // Notes    : Enables/Disables the Transparency feature
001488  001659  //          : 0 : Transparency disabled
001489  001660  //          : 1 : Transparency enabled
001490  001661        
001491  001662  func gfx_FrameDelay("milliseconds"), 0;         // 6  graphics animation frame delay
001492  001663  // Syntax   : gfx_FrameDelay("milliseconds");
001493  001664  // Usage    : gfx_FrameDelay(arg);
001494  001665  // Notes    : Sets the Video/Animation clip inter-frame delay for uSD_Video function.
001495  001666  //          : This setting will over-ride the embedded frame delay of the clip. After the event, the setting will autodisable, and
001496  001667  //          : if further inter-frame delays need overriding the setting must be reissued.
001497  001668  //          : This function will not control frame delays for a image control, refer to image control.
001498  001669  //          : value = 0 to 255 ms
001499  001670        
001500  001671  func gfx_ScreenMode("mode"), 0;                 // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001501  001672  // Usage    : gfx_ScreenMode(LANDSCAPE);
001502  001673  // Notes    : Set display orientation
001503  001674  //          : value = 1 : LANDSCAPE
001504  001675  //          : value = 2 : LANDSCAPE_R (Rotated)
001505  001676  //          : value = 3 : PORTRAIT
001506  001677  //          : value = 4 : PORTRAIT_R (Rotated)
001507  001678        
001508  001679  func gfx_OutlineColour("colour"), 0;            // 8  graphics rectangle/circle outline colour
001509  001680  // Syntax   : gfx_OutlineColour("colour");
001510  001681  // Usage    : gfx_OutlineColour(colr");
001511  001682  // Notes    : Sets the solid Rectangle or Circle objects outline colour.
001512  001683  //          : value = 0 : Disables this feature
001513  001684  //          : value = 1 to 0xFFFF : is the effective range
001514  001685        
001515  001686  func gfx_Contrast("value"), 0;                  // 9  graphics hardware contrast value 0-16 (0=off) *** only on internal driver devices
001516  001687  // Usage    : gfx_Contrast(val);
001517  001688  // Notes    : Set the display contrast
001518  001689  //          : 0 Display in low power mode. Display retains its contents in low power mode
001519  001690  //          : 1-16 Display on 1 = lowest, 16 = highest
001520  001691        
001521  001692  func gfx_LinePattern("value"), 0;               // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001522  001693  // Syntax   : gfx_LinePattern("value");
001523  001694  // Usage    : gfx_LinePattern(val);
001524  001695  // Notes    : Sets the line draw pattern for line drawing. If set to zero, lines are solid, else eac '1' bit represents
001525  001696  //          : a pixel that is turned off.
001526  001697  //          : 0 bits for pixels on
001527  001698  //          : 1 bits for pixels off
001528  001699        
001529  001700  func gfx_ColourMode("mode"), 0;                 // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001530  001701  // Syntax   : gfx_ColourMode("mode");
001531  001702  // Usage    : gfx_ColourMode(mod);
001532  001703  // Notes    : Set Graphics Colour mode
001533  001704  //          : COLOUR8  : 8bit colours
001534  001705  //          : COLOUR16 : 16bit colours
001535  001706        
001536  001707  //==============================================//
001537  001708  func _2C(), 0;                                  // 12 graphics  reserved
001538  001709  func _2D(), 0;                                  // 13 graphics  reserved
001539  001710  func _2E(), 0;                                  // 14 graphics  reserved
001540  001711  func _2F(), 0;                                  // 15 graphics  reserved
001541  001712  //==============================================//
001542  001713        
001543  001714        
001544  001715  //==============================================//
001545  001716  // generic constants                            //
001546  001717  //==============================================//
001547  001718  #CONST
001548  001725  #END
001549  001726        
001550  001727  //==============================================//
001551  001728  // joystick() function return constants         //
001552  001729  //==============================================//
001553  001730  #CONST
001554  001737  #END
001555  001738        
001556  001739  //==============================================//
001557  001740  // spi_Init(...)  mode arguments                //
001558  001741  //==============================================//
001559  001742  #CONST
001560  001752  #END
001561  001753        
001562  001754  //==============================================//
001563  001755  //Pin related constants                         //
001564  001756  //==============================================//
001565  001757  #CONST
001566  001768  #END
001567  001769        
001568  001770  //==============================================//
001569  001771  //gfx_Set() related constants                   //
001570  001772  //==============================================//
001571  001773  #CONST
001572  001786  #END
001573  001787        
001574  001788        
001575  001789  #CONST
001576  001800  #END
001577  001801        
001578  001802  //==============================================//
001579  001803  //txt_Set() related constants                   //
001580  001804  //==============================================//
001581  001805  #CONST
001582  001820  #END
001583  001821        
001584  001822  //==============================================//
001585  001823  //txt_Set() related arguments                   //
001586  001824  //==============================================//
001587  001825  #CONST
001588  001837  #END
001589  001838        
001590  001839        
001591  001840  //==============================================//
001592  001841  // Memory MAP                                   //
001593  001842  // system BYTE variables accesible with         //
001594  001843  // peekB and pokeB                              //
001595  001844  //==============================================//
001596  001845  #CONST
001597  001881  #END
001598  001882        
001599  001883        
001600  001884  //==============================================//
001601  001885  // system WORD variables accesible with peekW   //
001602  001886  // and pokeW or pointer access                  //
001603  001887  //==============================================//
001604  001888  #CONST
001605  001934  #END
001606  001935        
001607  001936  //==============================================//
001608  001937  // bit constants for SYS_FLAGS1                 //
001609  001938  //==============================================//
001610  001939  #CONST //SYS_FLAGS1
001611  001956  #END
001612  001957        
001613  001958  //==============================================//
001614  001959  // bit constants for SYS_FLAGS2                 //
001615  001960  //==============================================//
001616  001961  #CONST // SYS_FLAGS2
001617  001978  #END
001618  001979        
001619  001980        
001620  001981  //==============================================//
001621  001982  // EVE User Resources                           //
001622  001983  //==============================================//
001623  001984  #CONST
001624  001988  #END
001625  001989        
001626  001990  //------------------------------------------------------------------------------
001627  001991  //------------------------------------------------------------------------------
001628  001992  //------------------------------------------------------------------------------
001629  001993  //------------------------------------------------------------------------------
001630  001994  //------------------------------------------------------------------------------
001631  001995        
001632  001996        
001633  001997        
001634  001998        
001635  001999        
001636  002000        
001637  002001        
001638  002002        
001639  002003        
001640  002004        
001641  000002        
001642  000003  // Program Skeleton 1.0 generated 23/03/2016 14:21:52
001643  000004        
001644  000005        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\ledDigitsDisplayGoldelox.inc

001645  000006  #inherit "ledDigitsDisplayGoldelox.inc"
001646  000006  #inherit "ledDigitsDisplayGoldelox.inc"
001647  000001  // WARNING, this code will crash if newval exceeds maximum displayable number
001648  000002  func ledDigitsDisplay(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001649  000003      var i, k, l, num[4] ;
001650  000004      l := 0x500a | (Digits << 8) ;       // UDECxZ
001651  000005      to(num) ;
001652  000006      putnum(l, newval) ;
001653  000007      l := num ;
001654  000008      for (i := 0; i < Digits; i++)
001655  000009          if (i & 1)
001656  000010              k := (l[0] >> 8) & 0x0f ;
001657  000011              l++ ;
001658  000012          else
001659  000013              k := l[0] & 0x0f ;
001660  000014          endif
001661  000015          if ( LeadingBlanks && (i < Digits - MinDigits) )
001662  000016              if (k == 0)
001663  000017                  k := 10 ;
001664  000018              else
001665  000019                  LeadingBlanks := 0 ;
001666  000020              endif
001667  000021          endif
001668  000022          media_SetAdd(indexH, indexL) ;
001669  000023          media_VideoFrame(left+i*WidthDigit, top, k) ;
001670  000024      next
001671  000025  endfunc
001672  000026        
001673  000027  func ledDigitsDisplayD(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001674  000028      var i, k, l, num[4] ;
001675  000029      l := 0x500a | (Digits << 8) ;       // UDECxZ
001676  000030      to(num) ;
001677  000031      putnum(l, newval) ;
001678  000032      l := num ;
001679  000033      for (i := 0; i < Digits; i++)
001680  000034          if (i & 1)
001681  000035              k := (l[0] >> 8) & 0x0f ;
001682  000036              l++ ;
001683  000037          else
001684  000038              k := l[0] & 0x0f ;
001685  000039          endif
001686  000040          if ( LeadingBlanks && (i < Digits - MinDigits) )
001687  000041              if (k == 0)
001688  000042                  k := 10 ;
001689  000043              else
001690  000044                  LeadingBlanks := 0 ;
001691  000045              endif
001692  000046          endif
001693  000047          media_SetAdd(indexH, indexL) ;
001694  000048          media_VideoFrame(left-i*WidthDigit, top, k) ;
001695  000049      next
001696  000050  endfunc
001697  000051        
001698  000052  func ledDigitsDisplayR(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001699  000053      var i, k, l, num[4] ;
001700  000054      l := 0x500a | (Digits << 8) ;       // UDECxZ
001701  000055      to(num) ;
001702  000056      putnum(l, newval) ;
001703  000057      l := num ;
001704  000058      for (i := 0; i < Digits; i++)
001705  000059          if (i & 1)
001706  000060              k := (l[0] >> 8) & 0x0f ;
001707  000061              l++ ;
001708  000062          else
001709  000063              k := l[0] & 0x0f ;
001710  000064          endif
001711  000065          if ( LeadingBlanks && (i < Digits - MinDigits) )
001712  000066              if (k == 0)
001713  000067                  k := 10 ;
001714  000068              else
001715  000069                  LeadingBlanks := 0 ;
001716  000070              endif
001717  000071          endif
001718  000072          media_SetAdd(indexH, indexL) ;
001719  000073          media_VideoFrame(left, top-i*WidthDigit,k) ;
001720  000074      next
001721  000075  endfunc
001722  000076        
001723  000077  func ledDigitsDisplayL(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001724  000078      var i, k, l, num[4] ;
001725  000079      l := 0x500a | (Digits << 8) ;       // UDECxZ
001726  000080      to(num) ;
001727  000081      putnum(l, newval) ;
001728  000082      l := num ;
001729  000083      for (i := 0; i < Digits; i++)
001730  000084          if (i & 1)
001731  000085              k := (l[0] >> 8) & 0x0f ;
001732  000086              l++ ;
001733  000087          else
001734  000088              k := l[0] & 0x0f ;
001735  000089          endif
001736  000090          if ( LeadingBlanks && (i < Digits - MinDigits) )
001737  000091              if (k == 0)
001738  000092                  k := 10 ;
001739  000093              else
001740  000094                  LeadingBlanks := 0 ;
001741  000095              endif
001742  000096          endif
001743  000097          media_SetAdd(indexH, indexL) ;
001744  000098          media_VideoFrame(left, top+i*WidthDigit,k) ;
001745  000099      next
001746  000100  endfunc
001747  000101        
001748  000007        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

001749  000008  #inherit "4DGL_16bitColours.fnc"
001750  000008  #inherit "4DGL_16bitColours.fnc"
001751  000004  */
001752  000005        
001753  000006        
001754  000007        
001755  000008  #CONST
001756  000149  #END
001757  000150        
001758  000009        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

001759  000010  #inherit "VisualConst.inc"
001760  000010  #inherit "VisualConst.inc"
001761  000001  // Line Patterns
001762  000002  #constant  LPCOARSE    0xF0F0
001763  000002  #constant  LPCOARSE    0xF0F0
001764  000003  #constant  LPMEDIUM    0x3333
001765  000003  #constant  LPMEDIUM    0x3333
001766  000004  #constant  LPFINE      0xAAAA
001767  000004  #constant  LPFINE      0xAAAA
001768  000005  #constant  LPDASHDOT   0x03CF
001769  000005  #constant  LPDASHDOT   0x03CF
001770  000006  #constant  LPDASHDOTDOT 0x0333
001771  000006  #constant  LPDASHDOTDOT 0x0333
001772  000007  #constant  LPSOLID     0x0000
001773  000007  #constant  LPSOLID     0x0000
001774  000011        
file C:\Users\jlosi\Workspace\electronics-boards-public\power-management\bat\sw\Display\V2\BAT_display_V2.4DWork\BAT_display_V2Const.inc

001775  000012  #inherit "BAT_display_V2Const.inc"
001776  000012  #inherit "BAT_display_V2Const.inc"
001777  000001  // File generated 8/3/2023 10:07:33 AM
001778  000002  // Warning! This is a generated file, any manual changes will be
001779  000003  // lost during the next generation.
001780  000004        
001781  000005        
001782  000006  // object indexes for Inputs, Image Addresses + Input Array
001783  000007  #CONST
001784  000051  #END
001785  000052        
001786  000053        
001787  000013        
001788  000014  var combuf[10];
001789  000015  var display;
001790  000016  var command;
001791  000017  var value;
001792  000018  var value1;
001793  000019        
001794  000020  func main()
001795  000021       var voltage, current, charge, button;
001796  000022       var CPU_voltage, CPU_current, Motors_voltage, Motors_current;
001797  000023        
001798  000024        
001799  000025  //  Uncomment the following if uSD images, fonts or strings used.
001800  000026        
001801  000027      print("Starting\n") ;
001802  000028      while(!media_Init())
001803  000029          putstr("Drive not mounted...");
001804  000030          pause(1000);
001805  000031          gfx_Cls();
001806  000032          //pause(100);
001807  000033      wend
001808  000034        
001809  000035      setbaud(BAUD_115200);                             //  baud rate
001810  000036      //putstr("Default 115.2kb");
001811  000037      com_Init(combuf,7,0);           // <--- set comms buffer so com_Count can work
001812  000038        
001813  000039        
001814  000040      // CPU_voltage 1.1 generated 24/03/2016 09:28:02
001815  000041      media_SetAdd(iCPU_voltageH, iCPU_voltageL) ;      // point to the CPU_voltage image
001816  000042      media_Image(8, 100) ;                                 // show all digits at 0, only do this once
001817  000043        
001818  000044      // CPU_current 1.1 generated 24/03/2016 09:28:22
001819  000045      media_SetAdd(iCPU_currentH, iCPU_currentL) ;      // point to the CPU_current image
001820  000046      media_Image(8, 115) ;                                 // show all digits at 0, only do this once
001821  000047        
001822  000048      // Motors_voltage 1.1 generated 24/03/2016 09:28:39
001823  000049      media_SetAdd(iMotors_voltageH, iMotors_voltageL) ;      // point to the Motors_voltage image
001824  000050      media_Image(84, 100) ;                                 // show all digits at 0, only do this once
001825  000051        
001826  000052      // Motors_current 1.1 generated 24/03/2016 09:28:58
001827  000053      media_SetAdd(iMotors_currentH, iMotors_currentL) ;      // point to the Motors_current image
001828  000054      media_Image(84, 115) ;                                 // show all digits at 0, only do this once
001829  000055        
001830  000056      // Statictext7 1.0 generated 24/03/2016 10:44:44
001831  000057      media_SetAdd(iStatictext7H, iStatictext7L) ;      // point to the Statictext7 image
001832  000058      media_Image(4, 56) ;            // show image
001833  000059        
001834  000060        
001835  000061      // Statictext5 1.0 generated 24/03/2016 09:58:13
001836  000062      media_SetAdd(iStatictext5H, iStatictext5L) ;      // point to the Statictext5 image
001837  000063      media_Image(115, 56) ;            // show image
001838  000064        
001839  000065      // Statictext1 1.0 generated 24/03/2016 09:29:38
001840  000066      media_SetAdd(iStatictext1H, iStatictext1L) ;      // point to the Statictext1 image
001841  000067      media_Image(41, 100) ;            // show image
001842  000068        
001843  000069      // Statictext3 1.0 generated 24/03/2016 09:29:42
001844  000070      media_SetAdd(iStatictext3H, iStatictext3L) ;      // point to the Statictext3 image
001845  000071      media_Image(41, 114) ;            // show image
001846  000072        
001847  000073      // Statictext2 1.0 generated 24/03/2016 09:29:44
001848  000074      media_SetAdd(iStatictext2H, iStatictext2L) ;      // point to the Statictext2 image
001849  000075      media_Image(113, 100) ;            // show image
001850  000076        
001851  000077      // Statictext4 1.0 generated 24/03/2016 09:29:46
001852  000078      media_SetAdd(iStatictext4H, iStatictext4L) ;      // point to the Statictext4 image
001853  000079      media_Image(113, 114) ;            // show image
001854  000080        
001855  000081        
001856  000082      // Battery_percent 1.1 generated 24/03/2016 09:47:17
001857  000083      media_SetAdd(iBattery_percentH, iBattery_percentL) ;      // point to the Battery_percent image
001858  000084      media_Image(96, 56) ;                                 // show all digits at 0, only do this once
001859  000085        
001860  000086      charge:=0;
001861  000087      voltage := 0 ;
001862  000088      current:=0;
001863  000089      button := 0;
001864  000090      CPU_voltage:=0;
001865  000091      CPU_current:=0;
001866  000092      Motors_voltage:=0;
001867  000093      Motors_current:=0;
001868  000094        
001869  000095      repeat
001870  000096        
001871  000097          if(com_Count() >=3)
001872  000098              display := serin();
001873  000099              command := serin();
001874  000100              value := serin();
001875  000101              value1 := serin();
001876  000102              serout(display);
001877  000103              serout(command);
001878  000104              serout(value);
001879  000105              serout(value1);
001880  000106        
001881  000107              if(command == 0)
001882  000108                   charge:=value;
001883  000109              else if(command == 1)
001884  000110                   voltage:=value;
001885  000111              endif
001886  000112        
001887  000113          endif
001888  000114        
001889  000115        
001890  000116        
001891  000117          current++;
001892  000118          button++;
001893  000119          CPU_voltage++;
001894  000120          CPU_current++;
001895  000121          Motors_voltage++;
001896  000122          Motors_current++;
001897  000123        
001898  000124          if(current > 25)        current:=0;
001899  000125          if(button > 1)          button:=0;
001900  000126          if(CPU_voltage > 10)    CPU_voltage:=0;
001901  000127          if(CPU_current > 15)    CPU_current:=0;
001902  000128          if(Motors_voltage > 21) Motors_voltage:=0;
001903  000129          if(Motors_current > 26) Motors_current:=0;
001904  000130        
001905  000131        
001906  000132          // CPU 1.0 generated 24/03/2016 09:37:02
001907  000133          media_SetAdd(iCPUH, iCPUL) ;      // point to the CPU image
001908  000134          media_VideoFrame(0, 80, button) ;      // where numx is 0 (Off) or 1 (On)
001909  000135        
001910  000136          // Motors 1.0 generated 24/03/2016 09:37:04
001911  000137          media_SetAdd(iMotorsH, iMotorsL) ;      // point to the Motors image
001912  000138          media_VideoFrame(67, 80, button) ;      // where numx is 0 (Off) or 1 (On)
001913  000139        
001914  000140        
001915  000141          // Gauge1 1.0 generated 24/03/2016 09:46:53
001916  000142          media_SetAdd(iGauge1H, iGauge1L) ;      // point to the Gauge1 image
001917  000143          media_VideoFrame(43, 56, charge) ;          // where numx is 0 to 100 (for a displayed 0 to 100)
001918  000144        
001919  000145          // Battery_voltage 1.0 generated 24/03/2016 08:42:14
001920  000146          media_SetAdd(iBattery_voltageH, iBattery_voltageL) ;      // point to the Battery_voltage image
001921  000147          media_VideoFrame(0, 0, voltage) ;          // where numx is 0 to 20 (for a displayed 15 to 35)
001922  000148        
001923  000149        
001924  000150          // Battery_current 1.0 generated 24/03/2016 08:42:19
001925  000151          media_SetAdd(iBattery_currentH, iBattery_currentL) ;      // point to the Battery_current image
001926  000152          media_VideoFrame(67, 0, current) ;          // where numx is 0 to 25 (for a displayed 0 to 25)
001927  000153        
001928  000154        
001929  000155          ledDigitsDisplay(CPU_voltage, iiCPU_voltageH, iiCPU_voltageL, 8, 100, 3, 1, 9, 0) ;
001930  000156        
001931  000157          ledDigitsDisplay(CPU_current, iiCPU_currentH, iiCPU_currentL, 8, 115, 3, 1, 9, 0) ;
001932  000158        
001933  000159          ledDigitsDisplay(Motors_voltage, iiMotors_voltageH, iiMotors_voltageL, 84, 100, 3, 1, 9, 0) ;
001934  000160        
001935  000161          ledDigitsDisplay(Motors_current, iiMotors_currentH, iiMotors_currentL, 84, 115, 3, 1, 9, 0) ;
001936  000162        
001937  000163          ledDigitsDisplay(charge, iiBattery_percentH, iiBattery_percentL, 96, 56, 2, 1, 9, 0) ;
001938  000164        
001939  000165        
001940  000166        
001941  000167      forever
001942  000168        
001943  000169  endfunc
001944  000170        
Notice: no execution path to func 'ledDigitsDisplayL'
Notice: no execution path to func 'ledDigitsDisplayR'
Notice: no execution path to func 'ledDigitsDisplayD'
Notice: variable 'l' is being indexed (line 10 file:ledDigitsDisplayGoldelox.inc)
Notice: variable 'l' is being indexed (line 13 file:ledDigitsDisplayGoldelox.inc)


Symbol Table:
name                             decimal         hex
_1E                                 -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
_1F                                 -144  0xffffff70 (PmmC func) args[0] r=0  (not used)
_2C                                 -157  0xffffff63 (PmmC func) args[0] r=0  (not used)
_2D                                 -158  0xffffff62 (PmmC func) args[0] r=0  (not used)
_2E                                 -159  0xffffff61 (PmmC func) args[0] r=0  (not used)
_2F                                 -160  0xffffff60 (PmmC func) args[0] r=0  (not used)
__MAXMEM                             255  0x000000ff (const dword)  (usage 1)
__MAXPROG                           9216  0x00002400 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
_BOLD                                 16  0x00000010 (const dword)  (not used)
_CLIPPING                            256  0x00000100 (const dword)  (not used)
_COLOUR8                           16384  0x00004000 (const dword)  (not used)
_COMMINT                            4096  0x00001000 (const dword)  (not used)
_DISP16                            16384  0x00004000 (const dword)  (not used)
_DUMMY16                            8192  0x00002000 (const dword)  (not used)
_INVERSE                              64  0x00000040 (const dword)  (not used)
_ITALIC                               32  0x00000020 (const dword)  (not used)
_MEDIA_INSTALLED                       1  0x00000001 (const dword)  (not used)
_MEDIA_READ                            4  0x00000004 (const dword)  (not used)
_MEDIA_TYPE                            2  0x00000002 (const dword)  (not used)
_MEDIA_WRITE                           8  0x00000008 (const dword)  (not used)
_MEDIAFONT                         32768  0x00008000 (const dword)  (not used)
_MEDIAMODE                          4096  0x00001000 (const dword)  (not used)
_OPACITY                               4  0x00000004 (const dword)  (not used)
_OUTLINED                              8  0x00000008 (const dword)  (not used)
_OW_PIN                               16  0x00000010 (const dword)  (not used)
_PATTERNED                          8192  0x00002000 (const dword)  (not used)
_PENSIZE                               2  0x00000002 (const dword)  (not used)
_PROPFONT                          32768  0x00008000 (const dword)  (not used)
_PTR_TYPE                             32  0x00000020 (const dword)  (not used)
_RUNFLAG                            1024  0x00000400 (const dword)  (not used)
_RUNMODE                             256  0x00000100 (const dword)  (not used)
_SERMODE                            1024  0x00000400 (const dword)  (not used)
_SIGNED                              512  0x00000200 (const dword)  (not used)
_SINGLESTEP                         2048  0x00000800 (const dword)  (not used)
_STREAMLOCK                            1  0x00000001 (const dword)  (not used)
_STRMODE                             512  0x00000200 (const dword)  (not used)
_TEMP1                                64  0x00000040 (const dword)  (not used)
_TEMP2                               128  0x00000080 (const dword)  (not used)
_TXTMODE                            2048  0x00000800 (const dword)  (not used)
_UNDERLINED                          128  0x00000080 (const dword)  (not used)
ABS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ANALOGUE_10                            3  0x00000003 (const dword)  (not used)
ANALOGUE_8                             2  0x00000002 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                      1  0x00000001 (const dword)  (not used)
BAUD_110                           27271  0x00006a87 (const dword)  (not used)
BAUD_115200                           25  0x00000019 (const dword)  (usage 3)
BAUD_1200                           2499  0x000009c3 (const dword)  (not used)
BAUD_128000                           22  0x00000016 (const dword)  (not used)
BAUD_14400                           207  0x000000cf (const dword)  (not used)
BAUD_19200                           155  0x0000009b (const dword)  (not used)
BAUD_2400                           1249  0x000004e1 (const dword)  (not used)
BAUD_256000                           11  0x0000000b (const dword)  (not used)
BAUD_300                            9999  0x0000270f (const dword)  (not used)
BAUD_300000                           10  0x0000000a (const dword)  (not used)
BAUD_31250                            95  0x0000005f (const dword)  (not used)
BAUD_375000                            8  0x00000008 (const dword)  (not used)
BAUD_38400                            77  0x0000004d (const dword)  (not used)
BAUD_4800                            624  0x00000270 (const dword)  (not used)
BAUD_500000                            6  0x00000006 (const dword)  (not used)
BAUD_56000                            53  0x00000035 (const dword)  (not used)
BAUD_57600                            51  0x00000033 (const dword)  (not used)
BAUD_600                            4999  0x00001387 (const dword)  (not used)
BAUD_600000                            4  0x00000004 (const dword)  (not used)
BAUD_9600                            312  0x00000138 (const dword)  (not used)
beep                                 -38  0xffffffda (PmmC func) args[2] r=0  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
bits_Clear                           -15  0xfffffff1 (PmmC func) args[2] r=0  (not used)
bits_Flip                            -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
bits_Set                             -14  0xfffffff2 (PmmC func) args[2] r=0  (not used)
bits_Test                            -17  0xffffffef (PmmC func) args[2] r=1  (not used)
BLACK                                  0  0x00000000 (const dword)  (not used)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
C:\Users\jlosi\Workspace\electronics-boards-public\power-management\bat\sw\Display\V2\BAT_display_V2.4Dg    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
call                                -120  0xffffff88 (PmmC func) args[0] r=1  (not used)
charheight                          -125  0xffffff83 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -124  0xffffff84 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
CLIP_BOTTOM                          147  0x00000093 (const dword)  (not used)
CLIP_BOTTOM_POS                      143  0x0000008f (const dword)  (not used)
CLIP_LEFT                            144  0x00000090 (const dword)  (not used)
CLIP_LEFT_POS                        140  0x0000008c (const dword)  (not used)
CLIP_RIGHT                           146  0x00000092 (const dword)  (not used)
CLIP_RIGHT_POS                       142  0x0000008e (const dword)  (not used)
CLIP_TOP                             145  0x00000091 (const dword)  (not used)
CLIP_TOP_POS                         141  0x0000008d (const dword)  (not used)
CLIPPING                               3  0x00000003 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           11  0x0000000b (const dword)  (not used)
COM0                               65284  0x0000ff04 (const dword)  (not used)
com_AutoBaud                         -86  0xffffffaa (PmmC func) args[1] r=1  (not used)
com_Checksum                         -93  0xffffffa3 (PmmC func) args[0] r=1  (not used)
com_Count                            -89  0xffffffa7 (PmmC func) args[0] r=1  (usage 3)
com_Error                            -91  0xffffffa5 (PmmC func) args[0] r=1  (not used)
com_Full                             -90  0xffffffa6 (PmmC func) args[0] r=1  (not used)
com_Init                             -87  0xffffffa9 (PmmC func) args[3] r=0  (usage 3)
com_PacketSize                       -94  0xffffffa2 (PmmC func) args[0] r=1  (not used)
com_Reset                            -88  0xffffffa8 (PmmC func) args[0] r=0  (not used)
com_Sync                             -92  0xffffffa4 (PmmC func) args[0] r=1  (not used)
combuf                                 0  0x00000000 (mem) word[10] (global)  (usage 3)
command                               22  0x00000016 (mem) word (global)  (usage 12)
CONTRAST                               9  0x00000009 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disp_BlitPixelFill                  -101  0xffffff9b (PmmC func) args[2] r=0  (not used)
disp_BlitPixelsFromCOM              -103  0xffffff99 (PmmC func) args[1] r=0  (not used)
disp_BlitPixelsFromMedia            -105  0xffffff97 (PmmC func) args[1] r=0  (not used)
disp_BlitPixelsToCOM                -104  0xffffff98 (PmmC func) args[0] r=1  (not used)
disp_BlitPixelsToMedia              -102  0xffffff9a (PmmC func) args[0] r=1  (not used)
disp_Init                            -95  0xffffffa1 (PmmC func) args[2] r=0  (not used)
disp_ReadByte                        -99  0xffffff9d (PmmC func) args[0] r=1  (not used)
disp_ReadWord                       -100  0xffffff9c (PmmC func) args[0] r=1  (not used)
disp_SkipPixelsFromMedia            -106  0xffffff96 (PmmC func) args[1] r=0  (not used)
disp_WriteByte                       -96  0xffffffa0 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                    -97  0xffffff9f (PmmC func) args[1] r=0  (not used)
disp_WriteWord                       -98  0xffffff9e (PmmC func) args[1] r=0  (not used)
display                               20  0x00000014 (mem) word (global)  (usage 6)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   3  0x00000003 (const dword)  (not used)
drop                                -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -128  0xffffff80 (PmmC func) args[0] r=1  (not used)
exec                                -121  0xffffff87 (PmmC func) args[2] r=1  (not used)
FALSE                                  0  0x00000000 (const dword)  (not used)
FIRE                                   5  0x00000005 (const dword)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -113  0xffffff8f (PmmC func) args[0] r=0  (not used)
flash_ID                            -112  0xffffff90 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -111  0xffffff91 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT_HEIGHT                          152  0x00000098 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_MAX                             149  0x00000095 (const dword)  (not used)
FONT_OFFSET                          150  0x00000096 (const dword)  (not used)
FONT_TYPE                            148  0x00000094 (const dword)  (not used)
FONT_WIDTH                           151  0x00000097 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                            6  0x00000006 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
getsp                               -116  0xffffff8c (PmmC func) args[0] r=1  (not used)
GFX_BACK_COLOUR                       86  0x00000056 (const dword)  (not used)
gfx_BGcolour                        -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
GFX_BOTTOM                            99  0x00000063 (const dword)  (not used)
gfx_BoxTo                            -64  0xffffffc0 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
gfx_ChangeColour                     -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -51  0xffffffcd (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -52  0xffffffcc (PmmC func) args[4] r=0  (not used)
gfx_Clipping                        -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -65  0xffffffbf (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -41  0xffffffd7 (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -156  0xffffff64 (PmmC func) args[1] r=0  (not used)
gfx_Contrast                        -154  0xffffff66 (PmmC func) args[1] r=0  (not used)
gfx_Dot                              -60  0xffffffc4 (PmmC func) args[0] r=0  (not used)
gfx_FocusWindow                      -67  0xffffffbd (PmmC func) args[0] r=1  (not used)
gfx_FrameDelay                      -151  0xffffff69 (PmmC func) args[1] r=0  (not used)
gfx_GetPixel                         -54  0xffffffca (PmmC func) args[2] r=1  (not used)
gfx_Hline                            -47  0xffffffd1 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -62  0xffffffc2 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -63  0xffffffc1 (PmmC func) args[0] r=1  (not used)
GFX_LEFT                              96  0x00000060 (const dword)  (not used)
gfx_Line                             -46  0xffffffd2 (PmmC func) args[5] r=0  (not used)
GFX_LINE_PATTERN                      91  0x0000005b (const dword)  (not used)
gfx_LinePattern                     -155  0xffffff65 (PmmC func) args[1] r=0  (not used)
gfx_LineRel                          -45  0xffffffd3 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -44  0xffffffd4 (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -43  0xffffffd5 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -42  0xffffffd6 (PmmC func) args[2] r=0  (not used)
GFX_OBJECT_COLOUR                     87  0x00000057 (const dword)  (not used)
gfx_ObjectColour                    -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
gfx_Orbit                            -57  0xffffffc7 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
GFX_OUTLINE_COLOUR                    90  0x0000005a (const dword)  (not used)
gfx_OutlineColour                   -153  0xffffff67 (PmmC func) args[1] r=0  (not used)
gfx_PenSize                         -145  0xffffff6f (PmmC func) args[1] r=0  (not used)
gfx_Polygon                          -59  0xffffffc5 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -58  0xffffffc6 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -53  0xffffffcb (PmmC func) args[3] r=0  (not used)
gfx_Rectangle                        -49  0xffffffcf (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -50  0xffffffce (PmmC func) args[5] r=0  (not used)
GFX_RIGHT                             98  0x00000062 (const dword)  (not used)
GFX_SCREENMODE                       161  0x000000a1 (const dword)  (not used)
gfx_ScreenMode                      -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
gfx_Set                              -40  0xffffffd8 (PmmC func) args[2] r=0  (not used)
gfx_SetClipRegion                    -68  0xffffffbc (PmmC func) args[0] r=1  (not used)
GFX_STRINGMETRIX                     122  0x0000007a (const dword)  (not used)
GFX_TEMPSTORE1                       123  0x0000007b (const dword)  (not used)
GFX_TEXT_BGCOLOUR                     89  0x00000059 (const dword)  (not used)
GFX_TEXT_COLOUR                       88  0x00000058 (const dword)  (not used)
GFX_TOP                               97  0x00000061 (const dword)  (not used)
gfx_Tranparency                     -150  0xffffff6a (PmmC func) args[1] r=0  (not used)
gfx_TranparentColour                -149  0xffffff6b (PmmC func) args[1] r=0  (not used)
GFX_TRANSPARENTCOLOUR                121  0x00000079 (const dword)  (not used)
gfx_Triangle                         -55  0xffffffc9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -48  0xffffffd0 (PmmC func) args[4] r=1  (not used)
GFX_X1                               100  0x00000064 (const dword)  (not used)
GFX_X2                               102  0x00000066 (const dword)  (not used)
GFX_X_ORG                            104  0x00000068 (const dword)  (not used)
GFX_XMAX                             159  0x0000009f (const dword)  (not used)
GFX_Y1                               101  0x00000065 (const dword)  (not used)
GFX_Y2                               103  0x00000067 (const dword)  (not used)
GFX_Y_ORG                            105  0x00000069 (const dword)  (not used)
GFX_YMAX                             160  0x000000a0 (const dword)  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDELOX                               1  0x00000001 (const dword)  (usage 3)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
iBattery_currentH                      0  0x00000000 (const dword)  (usage 3)
iBattery_currentL                   7680  0x00001e00 (const dword)  (usage 3)
iBattery_percentH                      6  0x00000006 (const dword)  (usage 3)
iBattery_percentL                  28672  0x00007000 (const dword)  (usage 3)
iBattery_voltageH                      2  0x00000002 (const dword)  (usage 3)
iBattery_voltageL                  30720  0x00007800 (const dword)  (usage 3)
iCPU_currentH                          2  0x00000002 (const dword)  (usage 3)
iCPU_currentL                      26624  0x00006800 (const dword)  (usage 3)
iCPU_voltageH                          2  0x00000002 (const dword)  (usage 3)
iCPU_voltageL                      22528  0x00005800 (const dword)  (usage 3)
iCPUH                                  0  0x00000000 (const dword)  (usage 3)
iCPUL                                  0  0x00000000 (const dword)  (usage 3)
iGauge1H                               4  0x00000004 (const dword)  (usage 3)
iGauge1L                           17920  0x00004600 (const dword)  (usage 3)
iiBattery_percentH                     6  0x00000006 (const dword)  (usage 3)
iiBattery_percentL                 29184  0x00007200 (const dword)  (usage 3)
iiCPU_currentH                         2  0x00000002 (const dword)  (usage 3)
iiCPU_currentL                     27648  0x00006c00 (const dword)  (usage 3)
iiCPU_voltageH                         2  0x00000002 (const dword)  (usage 3)
iiCPU_voltageL                     23552  0x00005c00 (const dword)  (usage 3)
iiMotors_currentH                      6  0x00000006 (const dword)  (usage 3)
iiMotors_currentL                  37376  0x00009200 (const dword)  (usage 3)
iiMotors_voltageH                      6  0x00000006 (const dword)  (usage 3)
iiMotors_voltageL                  33280  0x00008200 (const dword)  (usage 3)
IMAGE_DELAY                          138  0x0000008a (const dword)  (not used)
IMAGE_HEIGHT                         137  0x00000089 (const dword)  (not used)
IMAGE_MODE                           139  0x0000008b (const dword)  (not used)
IMAGE_WIDTH                          136  0x00000088 (const dword)  (not used)
IMG_FRAME_COUNT                       93  0x0000005d (const dword)  (not used)
IMG_PIXEL_COUNT                       92  0x0000005c (const dword)  (not used)
iMotors_currentH                       6  0x00000006 (const dword)  (usage 3)
iMotors_currentL                   36352  0x00008e00 (const dword)  (usage 3)
iMotors_voltageH                       6  0x00000006 (const dword)  (usage 3)
iMotors_voltageL                   32256  0x00007e00 (const dword)  (usage 3)
iMotorsH                               0  0x00000000 (const dword)  (usage 3)
iMotorsL                            3584  0x00000e00 (const dword)  (usage 3)
INCVAL                               118  0x00000076 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INIT_TABLE_16BIT_DUMMY_READ          251  0x000000fb (const dword)  (not used)
INIT_TABLE_16BIT_INDEX_REG_MODE      253  0x000000fd (const dword)  (not used)
INIT_TABLE_8BIT_INDEX_REG_MODE       252  0x000000fc (const dword)  (not used)
INIT_TABLE_DELAY                     254  0x000000fe (const dword)  (not used)
INIT_TABLE_END                       255  0x000000ff (const dword)  (not used)
INIT_TABLE_LANDSCAPE                 249  0x000000f9 (const dword)  (not used)
INIT_TABLE_LANDSCAPE_R               247  0x000000f7 (const dword)  (not used)
INIT_TABLE_PORTRAIT                  250  0x000000fa (const dword)  (not used)
INIT_TABLE_PORTRAIT_R                248  0x000000f8 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
Inputs                                 0  0x00000000 (const dword)  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1                                    0  0x00000000 (const dword)  (not used)
IO2                                    1  0x00000001 (const dword)  (not used)
iStatictext1H                          6  0x00000006 (const dword)  (usage 3)
iStatictext1L                      40448  0x00009e00 (const dword)  (usage 3)
iStatictext2H                          6  0x00000006 (const dword)  (usage 3)
iStatictext2L                      40960  0x0000a000 (const dword)  (usage 3)
iStatictext3H                          6  0x00000006 (const dword)  (usage 3)
iStatictext3L                      41472  0x0000a200 (const dword)  (usage 3)
iStatictext4H                          6  0x00000006 (const dword)  (usage 3)
iStatictext4L                      41984  0x0000a400 (const dword)  (usage 3)
iStatictext5H                          6  0x00000006 (const dword)  (usage 3)
iStatictext5L                      43520  0x0000aa00 (const dword)  (usage 3)
iStatictext7H                          6  0x00000006 (const dword)  (usage 3)
iStatictext7L                      42496  0x0000a600 (const dword)  (usage 3)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -122  0xffffff86 (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
joystick                             -39  0xffffffd9 (PmmC func) args[0] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                     847  0x0000034f (User func) args[9] r=0  (usage 15)
ledDigitsDisplayD                 UNRESOLVED (User func) args[9] r=0  (not used)
ledDigitsDisplayL                 UNRESOLVED (User func) args[9] r=0  (not used)
ledDigitsDisplayR                 UNRESOLVED (User func) args[9] r=0  (not used)
LEFT                                   2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          10  0x0000000a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                  38  0x00000026 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -20  0xffffffec (PmmC func) args[2] r=1  (not used)
MDA                                65296  0x0000ff10 (const dword)  (not used)
MEDIA                                  7  0x00000007 (const dword)  (not used)
MEDIA_ADDR_HI                        109  0x0000006d (const dword)  (not used)
MEDIA_ADDR_LO                        108  0x0000006c (const dword)  (not used)
media_Flush                          -78  0xffffffb2 (PmmC func) args[0] r=1  (not used)
MEDIA_HEAD                            94  0x0000005e (const dword)  (not used)
media_Image                          -77  0xffffffb3 (PmmC func) args[2] r=0  (usage 33)
media_Init                           -79  0xffffffb1 (PmmC func) args[0] r=1  (usage 3)
media_ReadByte                       -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
media_ReadWord                       -74  0xffffffb6 (PmmC func) args[0] r=1  (not used)
media_SetAdd                         -71  0xffffffb9 (PmmC func) args[2] r=0  (usage 57)
media_SetSector                      -72  0xffffffb8 (PmmC func) args[2] r=0  (not used)
media_Video                          -69  0xffffffbb (PmmC func) args[2] r=0  (not used)
media_VideoFrame                     -70  0xffffffba (PmmC func) args[3] r=0  (usage 24)
media_WriteByte                      -75  0xffffffb5 (PmmC func) args[1] r=1  (not used)
media_WriteWord                      -76  0xffffffb4 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
MIDI                                  95  0x0000005f (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -19  0xffffffed (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
OBJECT_COLOUR                          2  0x00000002 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
ONEWIRE                                4  0x00000004 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                         8  0x00000008 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -26  0xffffffe6 (PmmC func) args[0] r=1  (not used)
OW_Read                              -35  0xffffffdd (PmmC func) args[0] r=1  (not used)
OW_Read9                             -36  0xffffffdc (PmmC func) args[0] r=1  (not used)
OW_Reset                             -34  0xffffffde (PmmC func) args[0] r=1  (not used)
OW_Write                             -37  0xffffffdb (PmmC func) args[1] r=0  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 3)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekB                                -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                               0  0x00000000 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -31  0xffffffe1 (PmmC func) args[1] r=0  (not used)
pin_LO                               -32  0xffffffe0 (PmmC func) args[1] r=0  (not used)
pin_Read                             -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
pin_Set                              -30  0xffffffe2 (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeB                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
pokeW                                -13  0xfffffff3 (PmmC func) args[2] r=0  (not used)
pop                                 -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
push                                -119  0xffffff89 (PmmC func) args[1] r=1  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (usage 9)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 3)
RAND                                 -24  0xffffffe8 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                            107  0x0000006b (const dword)  (not used)
RANDOM_LO                            106  0x0000006a (const dword)  (not used)
READ_GRAM_REG                        135  0x00000087 (const dword)  (not used)
RED                                63488  0x0000f800 (const dword)  (not used)
RELEASED                               0  0x00000000 (const dword)  (not used)
RIGHT                                  4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                            7  0x00000007 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SECTOR_ADDR_HI                       111  0x0000006f (const dword)  (not used)
SECTOR_ADDR_LO                       110  0x0000006e (const dword)  (not used)
SEED                                 -25  0xffffffe7 (PmmC func) args[1] r=0  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 12)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 12)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (usage 3)
setsp                               -115  0xffffff8d (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  5  0x00000005 (const dword)  (not used)
spi_Disable                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -107  0xffffff95 (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -108  0xffffff94 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -109  0xffffff93 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
strheight                           -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
strlen                              -123  0xffffff85 (PmmC func) args[1] r=1  (not used)
strwidth                            -126  0xffffff82 (PmmC func) args[1] r=1  (not used)
SWAP                                 -21  0xffffffeb (PmmC func) args[2] r=0  (not used)
SYS_FLAGS1                           126  0x0000007e (const dword)  (not used)
SYS_FLAGS2                           127  0x0000007f (const dword)  (not used)
SYS_OSTREAM                           95  0x0000005f (const dword)  (not used)
SYS_X_MAX                            132  0x00000084 (const dword)  (not used)
SYS_Y_MAX                            133  0x00000085 (const dword)  (not used)
SYSTEM                                 0  0x00000000 (const dword)  (not used)
SYSTEM_TIMER_HI                      113  0x00000071 (const dword)  (not used)
SYSTEM_TIMER_LO                      112  0x00000070 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEMP_MEDIA_ADDRHI                    120  0x00000078 (const dword)  (not used)
TEMP_MEDIA_ADDRLO                    119  0x00000077 (const dword)  (not used)
TEXT                               65288  0x0000ff08 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_DELAY                           156  0x0000009c (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                          155  0x0000009b (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_X_GAP                           157  0x0000009d (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XMAG                            153  0x00000099 (const dword)  (not used)
TEXT_Y_GAP                           158  0x0000009e (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YMAG                            154  0x0000009a (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                               114  0x00000072 (const dword)  (not used)
TIMER1                               115  0x00000073 (const dword)  (not used)
TIMER2                               116  0x00000074 (const dword)  (not used)
TIMER3                               117  0x00000075 (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 9)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                           5  0x00000005 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                     4  0x00000004 (const dword)  (not used)
TRUE                                   1  0x00000001 (const dword)  (not used)
tune_Continue                        -82  0xffffffae (PmmC func) args[0] r=0  (not used)
tune_End                             -84  0xffffffac (PmmC func) args[0] r=0  (not used)
tune_Pause                           -81  0xffffffaf (PmmC func) args[0] r=0  (not used)
tune_Play                            -80  0xffffffb0 (PmmC func) args[1] r=0  (not used)
tune_Playing                         -85  0xffffffab (PmmC func) args[0] r=1  (not used)
tune_Stop                            -83  0xffffffad (PmmC func) args[0] r=0  (not used)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Attributes                      -142  0xffffff72 (PmmC func) args[1] r=0  (not used)
txt_BGcolour                        -130  0xffffff7e (PmmC func) args[1] r=0  (not used)
txt_Bold                            -138  0xffffff76 (PmmC func) args[1] r=0  (not used)
txt_Delay                           -136  0xffffff78 (PmmC func) args[1] r=0  (not used)
txt_FGcolour                        -129  0xffffff7f (PmmC func) args[1] r=0  (not used)
txt_FontID                          -131  0xffffff7d (PmmC func) args[1] r=0  (not used)
txt_Height                          -133  0xffffff7b (PmmC func) args[1] r=0  (not used)
txt_Inverse                         -140  0xffffff74 (PmmC func) args[1] r=0  (not used)
txt_Italic                          -139  0xffffff75 (PmmC func) args[1] r=0  (not used)
txt_MoveCursor                       -28  0xffffffe4 (PmmC func) args[2] r=0  (not used)
txt_Opacity                         -137  0xffffff77 (PmmC func) args[1] r=0  (not used)
txt_Set                              -29  0xffffffe3 (PmmC func) args[2] r=0  (not used)
txt_Underline                       -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
txt_Width                           -132  0xffffff7c (PmmC func) args[1] r=0  (not used)
txt_Xgap                            -134  0xffffff7a (PmmC func) args[1] r=0  (not used)
txt_Ygap                            -135  0xffffff79 (PmmC func) args[1] r=0  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
USR_SP                               128  0x00000080 (const dword)  (not used)
USRSTACK                             384  0x00000180 (const dword)  (not used)
USRVARS                              129  0x00000081 (const dword)  (not used)
value                                 24  0x00000018 (mem) word (global)  (usage 12)
value1                                26  0x0000001a (mem) word (global)  (usage 6)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
VM_COLOUR                             84  0x00000054 (const dword)  (not used)
VM_OVERFLOW                           83  0x00000053 (const dword)  (not used)
VM_RETVAL                             85  0x00000055 (const dword)  (not used)
VX1                                  128  0x00000080 (const dword)  (not used)
VX2                                  130  0x00000082 (const dword)  (not used)
VY1                                  129  0x00000081 (const dword)  (not used)
VY2                                  131  0x00000083 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_GRAM_REG                       134  0x00000086 (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
