file D:\iCubHardware\trunk\electronics\private\P2015_06_BAT\SW\Display\V1\BAT_display.4Dg

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\GOLDELOX.fnc

000001  000001  #platform "GOLDELOX"
000002  000001  #platform "GOLDELOX"
000003  000007  */
000004  000010  */
000005  000011        
000006  000012      // for Goldelox GFX2
000007  000013        
000008  000014      #constant GOLDELOX      1
000009  000014      #constant GOLDELOX      1
000010  000015        
000011  000016      #constant __MAXMEM      255
000012  000016      #constant __MAXMEM      255
000013  000017      #constant __MAXPROG     9216
000014  000017      #constant __MAXPROG     9216
000015  000018        
000016  000019      #constant __PLATFORM    GOLDELOX
000017  000019      #constant __PLATFORM    GOLDELOX
000018  000020        
000019  000021        
000020  000022        
000021  000023        
000022  000024  //==============================================//
000023  000025  // initialization table additional commands     //
000024  000026  //==============================================//
000025  000027  #CONST
000026  000037  #END
000027  000038        
000028  000039  //==============================================//
000029  000040  // putch, putstr, putnum and print redirection  //
000030  000041  // constants                                    //
000031  000042  //==============================================//
000032  000043  #CONST
000033  000048  #END
000034  000049        
000035  000050  //==============================================//
000036  000051  // general number formatting constants          //
000037  000052  // for 'print' and 'putnum'                     //
000038  000053  //==============================================//
000039  000054  #CONST
000040  000186  #END
000041  000187        
000042  000188  // baud divisor rates
000043  000189  #CONST
000044  000211  #END
000045  000212        
000046  000213        
000047  000214        
000048  000219  */
000049  000220        
000050  000221        
000051  000222  //==============================================//
000052  000223  // EVE bios functions                           //
000053  000224  //==============================================//
000054  000225        
000055  000226  func serin(), 1;                                // read a byte from COM0
000056  000227  // Syntax   : serin();
000057  000228  // Usage    : char := serin();
000058  000229  // Notes    : Receives a character from the Serial Port COM0. The transmission format is:
000059  000230  //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000060  000231  //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000061  000232  //          : changed under program control by using the setbaud(...) function.
000062  000233  //          : Returns: -1 if no character is available
000063  000234  //          : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000064  000235  //          : Returns: positive value 0 to 255 for a valid character received
000065  000236        
000066  000237  func putch("char"), 0;                          // write single char to current output device
000067  000238  // Syntax   : putch("char");
000068  000239  // Usage    : putch("A");
000069  000240  // Notes    : Transmits a single byte from the Serial Port COM0. The transmission format is:
000070  000241  //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000071  000242  //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000072  000243  //          : changed under program control by using the setbaud(...) function.
000073  000244  //          : The arguments can be a variable, array element, expression or constant
000074  000245        
000075  000246  func serout("char"), 0;                         // write a byte to COM0
000076  000247  // Syntax   : serout1("char");
000077  000248  // Usage    : serout1(ch);
000078  000249  // Notes    : send character to COM1
000079  000250        
000080  000251  func setbaud("baudnum"), 0;                     // set baud rate of COM0
000081  000252  // Syntax   : setbaud(baud_number);
000082  000253  // Usage    : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000083  000254  // Notes   : specifies the baud rate divisor value or pre-defined constant
000084  000255  //          : The arguments can be a variable, array element, expression or constant
000085  000256  //          : Baud Number Divisor
000086  000257  //          : BAUD_110    27271
000087  000258  //          : BAUD_300    9999
000088  000259  //          : BAUD_600    4999
000089  000260  //          : BAUD_1200   2499
000090  000261  //          : BAUD_2400   1249
000091  000262  //          : BAUD_4800   624
000092  000263  //          : BAUD_9600   312
000093  000264  //          : BAUD_14400  207
000094  000265  //          : BAUD_19200  155
000095  000266  //          : BAUD_31250  95
000096  000267  //          : BAUD_38400  77
000097  000268  //          : BAUD_56000  53
000098  000269  //          : BAUD_57600  51
000099  000270  //          : BAUD_115200 25
000100  000271  //          : BAUD_128000 22
000101  000272  //          : BAUD_256000 11
000102  000273  //          : BAUD_300000 10
000103  000274  //          : BAUD_375000 8
000104  000275  //          : BAUD_500000 6
000105  000276  //          : BAUD_600000 4
000106  000277  //          :
000107  000278  //          : The baud rate is calculated with the following formula:
000108  000279  //          : rate-divisor = (3000000 / baud ) - 1
000109  000280        
000110  000281  func to("device"), 1;                           // output device redirection
000111  000282  // Syntax   : to(outstream);
000112  000283  // Usage    : to(APPEND); putstr("TWO ");
000113  000284  // Notes    : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000114  000285  //          :
000115  000286  //          : to() sends the printed output to destinations other than the screen. Normally, print just
000116  000287  //          : sends its output to the display in TEXT mode which is the default, however, the output from
000117  000288  //          : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000118  000289  //          : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000119  000290  //          : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000120  000291  //          : completed its action. The APPEND argument is used to send the printed output to the same
000121  000292  //          : place as the previous redirection. This is most useful for building string arrays, or adding
000122  000293  //          : sequential data to a media stream.
000123  000294  //          :
000124  000295  //          : Predefined Name   Constant    putch(), putstr(), putnum(), print() redirection
000125  000296  //          : APPEND            0x0000          Output is directed to the same stream that was previously assigned. Output is
000126  000297  //          :                                   appended to user array if previous redirection was to an array.
000127  000298  //          : COM0              0xFF04          Output is redirected to the COM (serial) port.
000128  000299  //          : TEXT              0xFF08          Output is directed to the screen (default).
000129  000300  //          : MDA               0xFF10          Output is directed to the SD or FLASH media.
000130  000301  //          : memory pointer    0x102<0x3FF     Output is redirect to the memory pointer argument.
000131  000302        
000132  000303  func pause("milliseconds"), 0;                  // blocking delay
000133  000304  // Syntax   : pause(milliseconds);
000134  000305  // Usage    : pause(1000);                      //pause for 1 second
000135  000306  // Notes    : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000136  000307        
000137  000308  func putnum("arg1","arg2"), 1;                  // print number to current output device
000138  000309  // Syntax   : putnum(format, value);
000139  000310  // Usage    : var := putnum(HEX, val);
000140  000311  // Notes    : prints a 16bit number in various formats to the current output stream, usually the display.
000141  000312  //          : Format: A constant that specifies the number format
000142  000313  //          : Value : The number to be printed
000143  000314  //          : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )    (    BINARY          )
000144  000315  //          : DEC  DECZ  DECZB      UDEC  UDECZ  UDECZB       HEX  HEXZ  HEXZB      BIN  BINZ    BINZB
000145  000316  //          : DEC1 DEC1Z DEC1ZB     UDEC1 UDEC1Z UDEC1ZB      HEX1 HEX1Z HEX1ZB     BIN1  BIN1Z   BIN1ZB
000146  000317  //          : DEC2 DEC2Z DEC2ZB     UDEC2 UDEC2Z UDEC2ZB      HEX2 HEX2Z HEX1ZB     BIN2  BIN2Z   BIN2ZB
000147  000318  //          : DEC3 DEC3Z DEC3ZB     UDEC3 UDEC3Z UDEC3ZB      HEX3 HEX3Z HEX1ZB     BIN3  BIN3Z   BIN3ZB
000148  000319  //          : DEC4 DEC4Z DEC4ZB     UDEC4 UDEC4Z UDEC4ZB      HEX4 HEX4Z HEX1ZB     BIN4  BIN4Z   BIN4ZB
000149  000320  //          : DEC5 DEC5Z DEC5ZB     UDEC5 UDEC5Z UDEC5ZB                            BIN5  BIN5Z   BIN5ZB
000150  000321  //          :                                                                       BIN6  BIN6Z   BIN6ZB
000151  000322  //          :                                                                       BIN7  BIN7Z   BIN7ZB
000152  000323  //          :                                                                       BIN8  BIN8Z   BIN8ZB
000153  000324  //          :                                                                       BIN9  BIN9Z   BIN9ZB
000154  000325  //          :                                                                       BIN10 BIN10Z  BIN10ZB
000155  000326  //          :                                                                       BIN11 BIN11Z  BIN11ZB
000156  000327  //          :                                                                       BIN12 BIN12Z  BIN12ZB
000157  000328  //          :                                                                       BIN13 BIN13Z  BIN13ZB
000158  000329  //          :                                                                       BIN14 BIN14Z  BIN14ZB
000159  000330  //          :                                                                       BIN15 BIN15Z  BIN15ZB
000160  000331  //          :                                                                       BIN16 BIN16Z  BIN16ZB
000161  000332  //          :
000162  000333  //          : field: Returns the the default width of the numeric field (digit count), usually ignored.
000163  000334  //          :============================================================================
000164  000335  //          : number formatting bits
000165  000336  //          :============================================================================
000166  000337  //          : bit 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
000167  000338  //          :     |  |  |  |   \___ ___/  |  \  /  \_____ _____/
000168  000339  //          :     |  |  |  |       V      |   V          V
000169  000340  //          :     |  |  |  |       |      |   |          |
000170  000341  //          :     |  |  |  |  digit count |   |          |
000171  000342  //          :     |  |  |  |  (nb 0 = 16) |   |          |____BASE (usually 2,10 or 16)
000172  000343  //          :     |  |  |  |              |   |
000173  000344  //          :     |  |  |  |              |   |___reserved (not used on Goldelox)
000174  000345  //          :     |  |  |  |              |
000175  000346  //          :     |  |  |  |              |____ string indicatior
000176  000347  //          :     |  |  |  |                      0x80 = [STR]
000177  000348  //          :     |  |  |  |                      0x81 = [CHR]
000178  000349  //          :     |  |  |  |______
000179  000350  //          :     |  |  |           1 = leading zeros included
000180  000351  //          :     |  |  |           0 = leading zeros suppressed
000181  000352  //          :     |  |  |
000182  000353  //          :     |  |  |_______
000183  000354  //          :     |  |           1 = leading zero blanking
000184  000355  //          :     |  |
000185  000356  //          :     |  |_____ sign bit (0 = signed, 1 = unsigned)
000186  000357  //          :     |
000187  000358  //          :     |______ 1 = space before unsigned number
000188  000359        
000189  000360        
000190  000361  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only)
000191  000362  // Syntax   :  This function is used only by the compiler
000192  000363  // Usage    :   Lookup8 and Lookup16
000193  000364  // Notes    : Reserved for use by compiler only, no use to the programmer
000194  000365        
000195  000366  func putstr("string"), 1;            // print string to current output device
000196  000367  // Syntax   : putstr(pointer);
000197  000368  // Usage    : putstr("HELLO\n");
000198  000369  // Notes    : putstr prints a string to the current output stream, usually the display. The argument can be
000199  000370  //          : a string constant, a pointer to a string, a pointer to an array, or a pointer to a data statement.
000200  000371  //          : The output of putstr can be redirected to the communications port, the media, or memory
000201  000372  //          : using the to(...); function.
000202  000373  //          : A string constant is automatically terminated with a zero.
000203  000374  //          : A string in a data statement is not automatically terminated with a zero.
000204  000375  //          : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000205  000376  //          : element packs 1 or 2 characters.
000206  000377  //          :
000207  000378  //          : Returns the pointer to the item that was printed.
000208  000379        
000209  000380  //==============================================//
000210  000381  // Memory Access Function Prototypes            //
000211  000382  //==============================================//
000212  000383        
000213  000384  func peekB("address"), 1;                       // read a byte from system or user memory
000214  000385  // Syntax   : peekB(address);
000215  000386  // Usage    : myvar := peekB(GFX_XMAX);
000216  000387  // Notes    : This function returns the 8 bit value that is stored at address.
000217  000388  //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte
000218  000389  //          : registers using the pre-defined constants. If peekB(..) or pokeB(..) are used to access other
000219  000390  //          : locations, the address must be doubled to get the correct pointer address.
000220  000391  //          :
000221  000392  //          : Address: The address of a memory byte. The address is usually a pre-defined system
000222  000393  //          : register address constant, The arguments can be a variable, array element, expression or constant.
000223  000394  //          : Return: The 8 bit value stored at address.
000224  000395        
000225  000396  func peekW("address"), 1;                       // read a word from system or user memory
000226  000397  // Syntax   : peekW(address);
000227  000398  // Usage    : myvar := peekW(SYSTEM_TIMER_LO);
000228  000399  // Notes    : This function returns the 16 bit value that is stored at address.
000229  000400  //          : The address of a memory word. The address is usually a pre-defined system register address constant,
000230  000401  //          : The arguments can be a variable, array element, expression or constant.
000231  000402        
000232  000403  func pokeB("address", "bytevalue"), 0;          // write a byte to system or user memory
000233  000404  // Syntax   : pokeB(address, byte_value);
000234  000405  // Usage    : pokeB(CLIP_TOP, 10);
000235  000406  // Notes    : This function writes a 8 bit value to a location specified by address.
000236  000407  //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte registers using the
000237  000408  //          : pre-defined constants. If peekB(..) or pokeB(..) are used to access other locations, the address must be
000238  000409  //          : doubled to get the correct pointer address.
000239  000410  //          :
000240  000411  //          : address: Address of a memory byte. It is usually a pre-defined system register address constant
000241  000412  //          : byte_value: The lower 8 bits of byte_value will be stored at address.
000242  000413  //          : Returns TRUE if poke address was a legal address (usually ignored).
000243  000414        
000244  000415  func pokeW("address", "wordvalue"), 0;          // write a word to system or user memory
000245  000416  // Syntax   : pokeW(address, word_value);
000246  000417  // Usage    : pokeW(TIMER2, 5000);
000247  000418  // Notes    : This function writes a 16 bit value to a location specified by address.
000248  000419  //          :
000249  000420  //          : Address: Address of a memory word. The address is usually a pre-defined system register  address constant
000250  000421  //          : word_value: The 16 bit word_value will be stored at address.
000251  000422  //          : The arguments can be a variable, array element, expression or constant.
000252  000423  //          :
000253  000424  //          : Returns TRUE if poke address was a legal address (usually ignored).
000254  000425        
000255  000426  //==============================================//
000256  000427  // bit manipulators                             //
000257  000428  //==============================================//
000258  000429        
000259  000430  func bits_Set("address","mask"), 0;             // set required bit(s) in memory (16bit operation)
000260  000431  // Syntax   : bits_Set(address, mask);
000261  000432  // Usage    : bits_Set(myval, 0xC0);
000262  000433  // Notes    : This function sets the required bits at address by 'ORing' the mask with the value stored at address.
000263  000434  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will
000264  000435  //          : not work with system register variables
000265  000436  //          :
000266  000437  //          : address :     The address of a user memory location.
000267  000438  //          : mask    :    The 16 bit mask containing bits to be set.
000268  000439  //          : The arguments can be a variable, array element, expression or constant.
000269  000440        
000270  000441  func bits_Clear("address","mask"), 0;           // clear required bit(s) in memory (16bit operation)
000271  000442  // Syntax   : bits_Clear(address, mask);
000272  000443  // Usage    : bits_Clear(myval, 0x3C00);
000273  000444  // Notes    : This function clears the required bits at address by 'ANDing' the inverted mask with the value stored at
000274  000445  //          : address.
000275  000446  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
000276  000447  //          : work with system register variables.
000277  000448  //          :
000278  000449  //          : address:     The address of a user memory location.
000279  000450  //          : mask   :     The 16 bit mask containing bits to be cleared.
000280  000451  //          : The arguments can be a variable, array element, expression or constant.
000281  000452        
000282  000453  func bits_Flip("address","mask"), 0;            // invert required bit(s) in memory (16bit operation)
000283  000454  // Syntax   : bits_Flip(address, mask);
000284  000455  // Usage    : bits_Flip(myval, 0x8802);
000285  000456  // Notes    : This function flips the required bits at address by 'XORing' the mask with the value stored at address.
000286  000457  //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
000287  000458  //          : work with system register variables.
000288  000459  //          :
000289  000460  //          : address: The address of a user memory location.
000290  000461  //          : mask   : The 16 bit mask containing bits to be flipped.
000291  000462  //          : The arguments can be a variable, array element, expression or constant.
000292  000463        
000293  000464  func bits_Test("address","mask"), 1;            // test required bit(s) in memory (16bit operation)
000294  000465        
000295  000466  //==============================================//
000296  000467  // Math Functions                               //
000297  000468  //==============================================//
000298  000469        
000299  000470  func ABS("value"), 1;                           // return a positive number
000300  000471  // Syntax   : ABS(value);
000301  000472  // Usage    : var := ABS(arg);
000302  000473  // Notes    : Returns the absolute value of an argument
000303  000474        
000304  000475  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000305  000476  // Syntax   : MIN(value1, value2);
000306  000477  // Usage    : var := MIN(arg1, arg2);
000307  000478  // Notes    : Returns the minimum of 2 arguments
000308  000479        
000309  000480  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000310  000481  // Syntax   : MAX(value1, value2);
000311  000482  // Usage    : var := MAX(arg1, arg2);
000312  000483  // Notes    : Returns the maximum of 2 arguments
000313  000484        
000314  000485  func SWAP("*var", "*var"), 0;                   // swap 2 variables, arguments must point to variables
000315  000486  // Syntax   : SWAP(var1, var2);
000316  000487  // Usage    : SWAP(var1, var2);
000317  000488  // Notes    : Swaps the contents of 2 variables or memory locations
000318  000489        
000319  000490  func SIN("angle"), 1;                           // return SIN of angle
000320  000491  // Syntax   : SIN(angle);
000321  000492  // Usage    : var := SIN(arg);
000322  000493  // Notes    : Returns the sine in radians of an argument in degrees
000323  000494  //          : the returned value range is from 127 to -127. The real
000324  000495  //          : cosine values vary from 1.0 to -1.0 so appropriate
000325  000496  //          : scaling must be done in user code.
000326  000497        
000327  000498  func COS("angle"), 1;                           // return COS of angle
000328  000499  // Syntax   : COS(angle);
000329  000500  // Usage    : var := COS(arg);
000330  000501  // Notes    : Returns the cosine in radians of an argument in degrees
000331  000502  //          : the returned value range is from 127 to -127. The real
000332  000503  //          : cosine values vary from 1.0 to -1.0 so appropriate
000333  000504  //          : scaling must be done in user code.
000334  000505        
000335  000506  func RAND(), 1;                                 // return a pseudo random number
000336  000507  // Syntax   : RAND();
000337  000508  // Usage    : var := RAND();
000338  000509  // Notes    : Returns a random number between 0 and 0xFFFF.
000339  000510  //          : The random number generator must first be seeded
000340  000511  //          : by using the SEED(number) function.
000341  000512        
000342  000513  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000343  000514  // Syntax   : SEED(number);
000344  000515  // Usage    : SEED(arg);
000345  000516  // Notes    : Seeds the random number generator.
000346  000517        
000347  000518  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000348  000519  // Syntax   : OVF();
000349  000520  // Usage    : var:= OVF();
000350  000521  // Notes    :
000351  000522        
000352  000523  func SQRT("number"), 1;                         // return square root of a number
000353  000524  // Syntax   : SQRT(number);
000354  000525  // Usage    : var := SQRT(number);
000355  000526  // Notes    :
000356  000527        
000357  000528  //==============================================//
000358  000529  // Text Control Function                        //
000359  000530  //==============================================//
000360  000531        
000361  000532  func txt_MoveCursor("line", "column"), 0;       // move to required text position (font size related)
000362  000533  // Syntax   : txt_SetCursor(line, column);
000363  000534  // Usage    : txt_SetCursor(arg1, arg2);
000364  000535  // Notes    : Moves the text Cursor to a new screen position set by
000365  000536  //          : line,column parameters.
000366  000537        
000367  000538  func txt_Set("mode", "value"), 0;               // various functions, (see constants below)
000368  000539  // Syntax   : txt_Set(mode, value);
000369  000540  // Usage    : txt_Set(arg1, arg2);
000370  000541  // Notes    : Sets various text related parameters used by other functions
000371  000542  //          :
000372  000543  //          : mode = TEXT_COLOUR (mode 0)
000373  000544  //          : txt_Set(TEXT_COLOUR, value);
000374  000545  //          : value = 0 to 0xFFFF, Black to White
000375  000546  //          : Sets the Text colour for the display
000376  000547  //          : Default = GREEN.
000377  000548  //          :
000378  000549  //          : mode = TEXT_HIGHLIGHT (mode 1)
000379  000550  //          : txt_Set(TEXT_HIGHLIGHT, value);
000380  000551  //          : value = 0 to 0xFFFF, Black to White
000381  000552  //          : Sets the Text background colour for the display. Effective
000382  000553  //          : when text mode is Opaque.
000383  000554  //          : Default = BLACK.
000384  000555  //          :
000385  000556  //          : mode = FONT_ID (mode 2)
000386  000557  //          : txt_Set(FONT_ID, value);
000387  000558  //          : value = FONT1, FONT2 or FONT3 for internal fonts
000388  000559  //          : else this value is the name of a font included
000389  000560  //          : in a users program in a data statement.
000390  000561  //          : Default = FONT SIZE 3.
000391  000562  //          :
000392  000563  //          : mode = TEXT_WIDTH  (mode 3)
000393  000564  //          : txt_Set(TEXT_WIDTH, value);
000394  000565  //          : value = 1 to 16
000395  000566  //          : Sets the Text Width multiplier
000396  000567  //          : text will be printed magnified horizontally
000397  000568  //          : by this factor, Default = 1.
000398  000569  //          :
000399  000570  //          : mode = TEXT_HEIGHT  (mode 4)
000400  000571  //          : txt_Set(TEXT_HEIGHT, value);
000401  000572  //          : value = 1 to 16
000402  000573  //          : Sets the Text Height multiplier
000403  000574  //          : text will be printed magnified vertically
000404  000575  //          : by this factor, Default = 1.
000405  000576  //          :
000406  000577  //          : mode = TEXT_XGAP  (mode 5)
000407  000578  //          : txt_Set(TEXT_XGAP, value);
000408  000579  //          : value = 1 to 32
000409  000580  //          : Sets the horizontal gap between characters
000410  000581  //          : The gap is in pixel units, Default = 0
000411  000582  //          :
000412  000583  //          : mode = TEXT_YGAP  (mode 6)
000413  000584  //          : txt_Set(TEXT_YGAP, value);
000414  000585  //          : value = 1 to 32
000415  000586  //          : Sets the vertical gap below characters
000416  000587  //          : The gap is in pixel units, Default = 0
000417  000588  //          :
000418  000589  //          : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000419  000590  //          : txt_Set(TEXT_PRINTDELAY, value);
000420  000591  //          : value = 0 to 255
000421  000592  //          : Sets the delay time (in ms) during character
000422  000593  //          : printing to give a 'teletype' like effect.
000423  000594  //          : Often used to attract attention to a string
000424  000595  //          : being printed which can often be missed if
000425  000596  //          : just suddenly appearing or changing.
000426  000597  //          : Default = 0 ms.
000427  000598  //          :
000428  000599  //          : mode = TEXT_OPACITY (mode 8)
000429  000600  //          : txt_Set(TEXT_OPACITY, value);
000430  000601  //          : value = TRANSPARENT (0) = Text Trasparent
000431  000602  //          : value = OPAQUE (1) = Text Opaque
000432  000603  //          : Sets the Opacity/Transparency of the text
000433  000604  //          : Default = 0 or TRANSPARENT
000434  000605  //          :
000435  000606  //          : mode = TEXT_BOLD (mode 9)
000436  000607  //          : txt_Set(TEXT_BOLD, value);
000437  000608  //          : value = dont care
000438  000609  //          : Sets Bold Text mode for the next string or char
000439  000610  //          : The feature automatically resets after printing
000440  000611  //          : using putstr or print has completed
000441  000612  //          :
000442  000613  //          : mode = TEXT_ITALIC (mode 10)
000443  000614  //          : txt_Set(TEXT_ITALIC, value);
000444  000615  //          : value = dont care
000445  000616  //          : Sets Italic Text mode for the next string or char
000446  000617  //          : The feature automatically resets after printing
000447  000618  //          : using putstr or print has completed
000448  000619        
000449  000620  //          : mode = TEXT_INVERSE (mode 11)
000450  000621  //          : txt_Set(TEXT_INVERSE, value);
000451  000622  //          : value = dont care
000452  000623  //          : Sets Inverse Text mode for the next string or char
000453  000624  //          : The feature automatically resets after printing
000454  000625  //          : using putstr or print has completed
000455  000626  //          :
000456  000627  //          : mode = TEXT_UNDERLINED (mode 12)
000457  000628  //          : txt_Set(TEXT_UNDERLINED, value);
000458  000629  //          : value = dont care
000459  000630  //          : Sets Underlined Text mode for the next string or char
000460  000631  //          : The feature automatically resets after printing
000461  000632  //          : using putstr or print has completed
000462  000633  //          :
000463  000634  //          : mode = TEXT_ATTRIBUTES (mode 13)
000464  000635  //          : txt_Set(TEXT_ATTRIBUTES, value);
000465  000636  //          : value = bits are defined as:
000466  000637  //          :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000467  000638  //          :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000468  000639  //          :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000469  000640  //          :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000470  000641  //          : Allows a combination of text attributes to be defined together
000471  000642  //          : by 'or'ing the bits together.
000472  000643  //          : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000473  000644  //          : The feature automatically resets after printing
000474  000645  //          : using putstr or print has completed.
000475  000646  //          : Bits 0-3 and 8-15 are reserved for future attributes.
000476  000647        
000477  000648  //==============================================//
000478  000649  // Hardware Function Prototypes                 //
000479  000650  //==============================================//
000480  000651  //        OUTPUT      0
000481  000652  //        INPUT       1
000482  000653  //        ANALOGUE_8  2
000483  000654  //        ANALOGUE_10 3
000484  000655  //        ONEWIRE     4
000485  000656  //        SOUND        5
000486  000657        
000487  000658  func pin_Set("mode", "pin"), 0;                 // set pin to required mode
000488  000659  // Syntax   : pin_Set(mode, pin);
000489  000660  // Usage    : pin_Set(arg1, arg2);
000490  000661  // Notes    : Sets the appropriate pins to Inputs or Outputs
000491  000662  //          :
000492  000663        
000493  000664  func pin_HI("pin"), 0;                          // set pin to logic '1'
000494  000665  // Syntax   : pin_HI(pin);
000495  000666  // Usage    : pin_HI(PIN_0);
000496  000667  //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
000497  000668  //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
000498  000669  // Notes    : Outputs a logic "High" (3.3V) on the appropriate
000499  000670  //          : pin that was previously selected as an Output.
000500  000671        
000501  000672  func pin_LO("pin"), 0;                          // set pin to logic '0'
000502  000673  // Syntax   : pin_LO(pin);
000503  000674  // Usage    : pin_LO(PIN_0);
000504  000675  // Notes    : Outputs a logic "Low" (0V) on the appropriate
000505  000676  //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
000506  000677  //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
000507  000678  //          : pin that was previously  selected as an Output.
000508  000679        
000509  000680  func pin_Read("pin"), 1;                        // read pin, logic or analogue
000510  000681  // Syntax   : pin_Read(PIN_0);
000511  000682  // Usage    : arg1 := pin_Read(arg2);
000512  000683  // Notes    : Reads the logic state or analogue value of the appropriate
000513  000684  //          : pin that was previously selected as an Input or *Analogue.
000514  000685  //          : pin = 0 : Read the state of the RUN pin
000515  000686  //          : Returns a 0 (logic low) or 1 (logic high) or n Analogue.
000516  000687  //          : *NB: Analogue is only available on PIN_1
000517  000688        
000518  000689  func OW_Reset(), 1;                             // issue 1wire reset command
000519  000690  // Syntax   : OW_Reset();
000520  000691  // Usage    : OW_Reset();
000521  000692  // Notes    : Resets  ONEWIRE device
000522  000693  //          : Returns the status, 0 = ACK.
000523  000694  //          :
000524  000695        
000525  000696  func OW_Read(), 1;                              // read data from 1wire bus
000526  000697  // Syntax   : OW_Read();
000527  000698  // Usage    : arg1 := OW_Read();
000528  000699  // Notes    : Reads value of the ONEWIRE pin
000529  000700  //          : that was previously selected for ONEWIRE comms.
000530  000701  //          :
000531  000702  //          : pin = 0 : the next byte from the ONEWIRE bus
000532  000703        
000533  000704  func OW_Read9(), 1;                             // read data from 1wire bus, 9bit mode
000534  000705  // Syntax   : OW_Read9();
000535  000706  // Usage    : OW_Read9();
000536  000707  // Notes    : Reads 9 bit value of the appropriate ONEWIRE pin
000537  000708  //          : that was previously selected for ONEWIRE comms.
000538  000709  //          :
000539  000710  //          : read the 9 bits from the ONEWIRE bus
000540  000711        
000541  000712  func OW_Write("value"), 0;                      // write value to 1wire device
000542  000713  // Syntax   : OW_Write(arg);
000543  000714  // Usage    : OW_Write(arg);
000544  000715  // Notes    : Sends ONEWIRE data on the appropriate
000545  000716  //          : pin that was previously  selected as ONEWIRE comms.
000546  000717  //          :
000547  000718  //          : write arg to the ONEWIRE bus
000548  000719        
000549  000720  func beep("pitch","duration"), 0;               // generate a note on specified port pin
000550  000721  // Syntax   : beep(note, duration);
000551  000722  // Usage    : Beep(20, 50);
000552  000723  // Notes    : Generates a beep for a certain period of time
000553  000724  //          : note    : A value (usually a constant) specifying the frequency of the note.
000554  000725  //          : duration: specifies the time in milliseconds that the note will be played for.
000555  000726  //          : The arguments can be a variable, array element, expression or constant
000556  000727        
000557  000728  func joystick(), 1;                             // read the joystick value
000558  000729  // Syntax   : Joystick();
000559  000730  // Usage    : var := Joystick();
000560  000731  // Notes    : Returned values are:-
000561  000732  //          :    RELEASED 0
000562  000733  //          :    UP       1
000563  000734  //          :    LEFT     2
000564  000735  //          :    DOWN     3
000565  000736  //          :    RIGHT    4
000566  000737  //          :    FIRE     5
000567  000738        
000568  000739  //==============================================//
000569  000740  // Graphics Mode Function Prototypes            //
000570  000741  //==============================================//
000571  000742        
000572  000743  func gfx_Set("mode", "value"), 0;               // set various graphics functions
000573  000744  // Syntax   : gfx_Set(mode, value);
000574  000745  // Usage    : gfx_Set(arg1, arg2);
000575  000746  // Notes    : Sets various graphics parameters used by other functions
000576  000747  //          :
000577  000748  //          : mode = 0 : PenSize
000578  000749  //          : gfx_Set(PEN_SIZE, value);
000579  000750  //          : value = SOLID   : Object Solid
000580  000751  //          : value = OUTLINE : Object Outline
000581  000752  //          : Sets the size of the Pen used by most graphics objects
000582  000753  //          :
000583  000754  //          : mode = 1 : Background Colour
000584  000755  //          : gfx_Set(1, value);
000585  000756  //          : value = 0 to 0xFFFF, Black to White
000586  000757  //          : Sets the Background colour of the screen for gfx_Cls();
000587  000758  //          :
000588  000759  //          : mode = 2 : Object Colour
000589  000760  //          : gfx_Set(OBJECT_COLOUR, value);
000590  000761  //          : value = 0 to 0xFFFF, Black to White
000591  000762  //          : Sets the Object colour used in various functions
000592  000763  //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000593  000764  //          :
000594  000765  //          : mode = 3 : Clipping
000595  000766  //          : gfx_Set(CLIPPING, value);
000596  000767  //          : value = OFF : Clipping disabled
000597  000768  //          : value = ON  : Clipping enabled
000598  000769  //          : Enables/Disables the Clipping feature
000599  000770  //          :
000600  000771  //          : mode = 7 : Set required screen behaviour
000601  000772  //          : gfx_Set(SCREEN_MODE, value);
000602  000773  //          : value = LANDSCAPE         1
000603  000774  //          : value = LANDSCAPE_R     2
000604  000775  //          : value = PORTRAIT         3
000605  000776  //          : value = PORTRAIT_R     4
000606  000777  //          :
000607  000778  //          : mode = 8 : Outline Colour
000608  000779  //          : gfx_Set(OUTLINE_COLOUR, value);
000609  000780  //          : value = 1 to 0xFFFF, OFF to White
000610  000781  //          : Sets the Rectangle or Circle objects outline colour
000611  000782  //          : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000612  000783  //          : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000613  000784  //          :
000614  000785  //          : mode = 9 : Contrast
000615  000786  //          : gfx_Set(CONTRAST, value);
000616  000787  //          : value = 1 to 16, 1=lowest, 16=highest contrast
000617  000788  //          : value = 0 puts display into low power mode.
000618  000789  //          : Sets the contrast
000619  000790  //          : gfx_Set(CONTRAST, OFF); may be used for this
000620  000791        
000621  000792  func gfx_Cls(), 0;                    // clear the screen
000622  000793  // Syntax   : gfx_Cls();
000623  000794  // Usage    : gfx_Cls();
000624  000795  // Notes    : Clears the screen with current background colour
000625  000796        
000626  000797  func gfx_MoveTo("x", "y"), 0;                   // set glb_X1 and glb_Y1 to required co-ordinate
000627  000798  // Syntax   : gfx_MoveTo(x, y);
000628  000799  // Usage    : gfx_MoveTo(arg1, arg2);
000629  000800  // Notes    : Moves the origin to a new x,y position
000630  000801        
000631  000802  func gfx_MoveRel("x", "y"), 0;                  // set glb_X1 and glb_Y1 to new relative offset
000632  000803  // Syntax   : gfx_MoveTo(x, y);
000633  000804  // Usage    : gfx_MoveTo(arg1, arg2);
000634  000805  // Notes    : Moves the origin relative to  x,y and sets a new position
000635  000806        
000636  000807  func gfx_LineTo("x1", "y1"), 0;                 // draw line from current origin to new point
000637  000808  // Syntax   : gfx_LineTo(x1, y1);
000638  000809  // Usage    : gfx_LineTo(arg1, arg2);
000639  000810  // Notes    : Draws a Line from the origin x,y to x1,y1.
000640  000811  //          : The new origin is then set to x1, y1. Line colour needs
000641  000812  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000642  000813        
000643  000814  func gfx_LineRel("x1", "y1"), 0;                // draw line from current origin to new relative offset
000644  000815  // Syntax   : gfx_LineRel(x1, y1);
000645  000816  // Usage    : gfx_LineRel(arg1, arg2);
000646  000817  // Notes    : Draws a Line from the origin x,y to x1,y1.
000647  000818  //          : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000648  000819  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000649  000820        
000650  000821  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;  // draw line, can be patterned
000651  000822  // Syntax   : gfx_Line(x1, y1, x2, y2, colr);
000652  000823  // Usage    : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000653  000824  // Notes    : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000654  000825        
000655  000826  func gfx_Hline("y", "x1", "x2", "colr"), 1;     // draw Hline, can be patterned
000656  000827  // Syntax   : gfx_Hline(y, x1, x2, colr);
000657  000828  // Usage    : var := gfx_Hline(arg1, arg2, arg3, arg4);
000658  000829  // Notes    : Plots a coloured Horizontal Line y pixels away from origin
000659  000830  //          : starting from x1 to x2
000660  000831  //          : Returns number of pixels plotted
000661  000832        
000662  000833  func gfx_Vline("x", "y1", "y2", "colr"), 1;    // draw Vline, can be patterned
000663  000834  // Syntax   : gfx_Vline(x, y1, y2, colr);
000664  000835  // Usage    : var := gfx_Vline(arg1, arg2, arg3, arg4);
000665  000836  // Notes    : Plots a coloured Vertical Line x pixels away from origin
000666  000837  //          : starting from y1 to y2
000667  000838  //          : Returns number of pixels plotted
000668  000839        
000669  000840  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;  // draw open rectangle,line can be patterned
000670  000841  // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
000671  000842  // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000672  000843  // Notes    : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000673  000844  //          : bottom corner (x2,y2) on the screen.
000674  000845        
000675  000846  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;  // draw filled rectangle
000676  000847  // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000848  // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000849  // Notes    : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000679  000850  //          : bottom corner (x2,y2) on the screen.
000680  000851        
000681  000852  func gfx_Circle("x", "y", "rad", "colr"), 0;  // draw open circle
000682  000853  // Syntax   : gfx_Circle(x, y, rad, colr);
000683  000854  // Usage    : gfx_Circle(arg1, arg2, arg3, arg4);
000684  000855  // Notes    : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000685  000856        
000686  000857  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;        // draw filled circle
000687  000858  // Syntax   : gfx_CircleFilled(x, y, rad, colr);
000688  000859  // Usage    : gfx_CircleFilled(arg1, arg2, arg3, arg4);
000689  000860  // Notes    : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000690  000861        
000691  000862  func gfx_PutPixel("x", "y", "colr"), 0;      // set point at x y
000692  000863  // Syntax   : gfx_PutPixel(x, y, colr);
000693  000864  // Usage    : gfx_PutPixel(arg1, arg2, arg3);
000694  000865  // Notes    : Plots a coloured pixel on the screen at x,y location
000695  000866        
000696  000867  func gfx_GetPixel("x", "y"), 1;             // read colour at point x y
000697  000868  // Syntax   : gfx_GetPixel(x, y);
000698  000869  // Usage    : var := gfx_GetPixel(arg1, arg2);
000699  000870  // Notes    : Reads and returns the colour value of a pixel at location x,y
000700  000871        
000701  000872  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000702  000873  // Syntax   : gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000703  000874  // Usage    : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000704  000875  // Notes    : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000705  000876  //          : Vertices must be specified in an anti-clockwise fashion
000706  000877        
000707  000878  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;  // set result holders for orbit command
000708  000879  // Syntax   : gfx_OrbitInit(&x_orb, &y_orb);
000709  000880  // Usage    : gfx_OrbitInit(&arg1, &arg2);
000710  000881  // Notes    : Sets up the Orbit function parameters.
000711  000882  //          : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000712  000883  //          : variables that get updated after calling gfx_Orbit(,,) function.
000713  000884  //          : The coordiantaes are calculated relative to the origin
000714  000885  //          : obtained by using the gfx_MoveTo(x, y) function.
000715  000886        
000716  000887  func gfx_Orbit("angle", "distance"), 0;     // calculate point at angle, distance
000717  000888  // Syntax   : gfx_Orbit(angle, distance);
000718  000889  // Usage    : gfx_Orbit(arg1, arg2);
000719  000890  // Notes    : The Orbit function calcualtes the x, y coordinates of a distant point whose
000720  000891  //          : only known parameters are the angle and the distance from the current origin.
000721  000892        
000722  000893  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;  // draw a polyline from a table of points
000723  000894  // Syntax   : gfx_Polyline(n, &vx, &vy, colr);
000724  000895  // Usage    : gfx_Polyline(arg1, x[array], y[array], arg2);
000725  000896  // Notes    : This function is very similar to the Polygon function
000726  000897  //          : with the exception of the 1st and the last vertices not joined.
000727  000898        
000728  000899  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;   // draw a polygon from a table of points
000729  000900  // Syntax   : gfx_Polygon(n, &vx, &vy, colr);
000730  000901  // Usage    : gfx_Polygon(arg1, x[array], y[array], arg2);
000731  000902  // Notes    : Plots a coloured Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000732  000903  //          : Vertices must be minimum of 3 and can be specified in any fashion
000733  000904        
000734  000905  func gfx_Dot(), 0;                              // set point at glb_X glb_Y, default colour
000735  000906  // Syntax   : gfx_Dot();
000736  000907  // Usage    : gfx_Dot();
000737  000908  // Notes    : Places a coloured dot at the origin
000738  000909        
000739  000910  func gfx_Bullet("r"), 0;                        // draw circle at glb_X glb_Y, default colour
000740  000911  // Syntax   : gfx_Dot(r);
000741  000912  // Usage    : gfx_Dot(radius);
000742  000913  // Notes    : Places a coloured circle at the origin with radius r
000743  000914  //          : colour needs to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000744  000915  //          : and the PenSize setting determines if circle is solid or outline.
000745  000916        
000746  000917  func gfx_IncX(), 1;                            // increment global origin glb_X, returning new value
000747  000918  // Syntax   : gfx_IncX();
000748  000919  // Usage    : var := gfx_IncX();
000749  000920  // Notes    : Increments the x coordinate of the origin
000750  000921  // Notes    : Returns new value
000751  000922        
000752  000923  func gfx_IncY(), 1;                            // increment global origin glb_Y, returning new value
000753  000924  // Syntax   : gfx_IncY();
000754  000925  // Usage    : var := gfx_IncY();
000755  000926  // Notes    : Increments the y coordinate of the origin
000756  000927  // Notes    : Returns new value
000757  000928        
000758  000929  func gfx_BoxTo("x1", "y1"), 0;                 // draw rectangle from current origin to x1 y1
000759  000930  // Syntax   : gfx_BoxTo(x1, y1);
000760  000931  // Usage    : gfx_BoxTo(arg1, arg2);
000761  000932  // Notes    : Draws a Rectangle from the origin x,y to x1,y1.
000762  000933  //          : The new origin is then set to x1,y1. Rectangle colour needs
000763  000934  //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000764  000935  //          : and the PenSize setting determines if Box is solid or outline.
000765  000936        
000766  000937  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;  // set the cipping area
000767  000938  // Syntax   : gfx_ClipWindow(x1, y1, x2, y2);
000768  000939  // Usage    : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000769  000940  // Notes    : Specifies a clipping window region on the screen such that any objects
000770  000941  //          : and text placed onto the screen will be clipped and displayed only
000771  000942  //          : within that region. For the clipping window to take effect, "Clipping"
000772  000943  //          : must be enabled seperately using the gfx_Set(CLIPPING, ON) function.
000773  000944        
000774  000945  func gfx_ChangeColour("oldcolr", "newcolr"), 0;  // change pixel colour in clipping area
000775  000946  // Syntax   : gfx_ChangeColour(oldcolr, newcolr);
000776  000947  // Usage    : gfx_ChangeColour(0xFF00, 0xFFFF);
000777  000948  // Notes    : Changes the pixel colour in the currently focussed clipping region
000778  000949        
000779  000950  func gfx_FocusWindow(), 1;                      // focus on the clipping area, returning the pixel count
000780  000951  // Syntax   : gfx_FocusWindow();
000781  000952  // Usage    : var := gfx_FocusWindow();
000782  000953  // Notes    : sets the focus on the clipping region and returns number of pixels in the region.
000783  000954        
000784  000955  func gfx_SetClipRegion(), 1;                    // set clipping area to the most recent extents
000785  000956  // Syntax   : gfx_SetClipRegion();
000786  000957  // Usage    : VAR := gfx_SetClipRegion();
000787  000958  // Notes    :
000788  000959        
000789  000960  //==============================================//
000790  000961  // uSD/FLASH Function Prototypes                //
000791  000962  //==============================================//
000792  000963        
000793  000964  func media_Video("x", "y"), 0;                  // display movie at position x y
000794  000965  // Syntax   : media_Video(x, y);
000795  000966  // Usage    : media_Video(arg1, arg2);
000796  000967  // Notes    : Play a Video/Animation clip from the uSD card at screen location
000797  000968  //          : specified by x,y (top left corner). The location of the clip in the
000798  000969  //          : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000799  000970        
000800  000971  func media_VideoFrame("x", "y","framenumber"), 0;// display required frame from a movie at x y
000801  000972  // Syntax   : media_VideoFrame(Frame_number);
000802  000973  // Usage    : arg1 := media_VideoFrame();
000803  000974  // Notes    : After a pointer to a valid video has been set with media_SetSector,
000804  000975  //          : calling this function shows each fram sequentially, returning
000805  000976  //          : the number of frames remaining. The position of the image is
000806  000977  //          : at the current origin as set with gfx_MoveTo(...);
000807  000978        
000808  000979  func media_SetAdd("HiWord", "LoWord"), 0;       // set stream byte address
000809  000980  // Syntax   : media_SetAdd(AddHiWord, AddLoWord);
000810  000981  // Usage    : media_SetAdd(arg1, arg2);
000811  000982  // Notes    : Set uSD internal Address pointer for bytewise access
000812  000983        
000813  000984  func media_SetSector("HiWord", "LoWord"), 0;    // set stream sector address
000814  000985  // Syntax   : media_SetSector(SectHiWord, SectLoWord);
000815  000986  // Usage    : media_SetSector(arg1, arg2);
000816  000987  // Notes    : Set uSD internal Sector pointer for sector block access
000817  000988        
000818  000989  func media_ReadByte(), 1;                       // read a byte at the current stream position
000819  000990  // Syntax   : media_RdByte();
000820  000991  // Usage    : var := media_RdByte();
000821  000992  // Notes    : Reads and Returns a single byte of data from the
000822  000993  //          : uSD card pointed to by the internal Address pointer.
000823  000994  //          : After the read the Address pointer is automatically
000824  000995  //          : incremented by 1.
000825  000996        
000826  000997  func media_ReadWord(), 1;                       // read a word at the current stream position
000827  000998  // Syntax   : media_ReadWord();
000828  000999  // Usage    : var := media_ReadWord();
000829  001000  // Notes    : Reads and Returns a single word of data from the
000830  001001  //          : uSD card pointed to by the internal Address pointer.
000831  001002  //          : After the read the Address pointer is automatically
000832  001003  //          : incremented by 1.
000833  001004        
000834  001005  func media_WriteByte("byte"), 1;                // write a byte to the current stream position
000835  001006  // Syntax   : media_WriteByte(arg1);
000836  001007  // Usage    : var := media_WriteByte(arg1);
000837  001008  // Notes    : Writes and Returns xxxxx
000838  001009  //          : After the write the Address pointer is automatically
000839  001010  //          : incremented by 1.
000840  001011        
000841  001012  func media_WriteWord("word"), 1;                // write a word to the current stream position
000842  001013  // Syntax   : media_WriteWord(arg1);
000843  001014  // Usage    : var := media_WriteWord(arg1);
000844  001015  // Notes    : Writes and Returns xxxxx
000845  001016  //          : After the write the Address pointer is automatically
000846  001017  //          : incremented by 1.
000847  001018        
000848  001019  func media_Image("x", "y"), 0;                  // display image at position x y
000849  001020  // Syntax   : media_Image(x, y);
000850  001021  // Usage    : media_Image(arg1, arg2);
000851  001022  // Notes    : Display an image from the uSD card at screen location
000852  001023  //          : specified by x,y (top left corner). The location of the
000853  001024  //          : Image in the uSD card must be specified by
000854  001025  //          : media_setSector(Image_Sector_Add) function.
000855  001026        
000856  001027  func media_Flush(), 1;                          // after writing to media, flush the sector and write
000857  001028  // Syntax   : media_Flush();
000858  001029  // Usage    : var := media_Flush();
000859  001030  // Notes    : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
000860  001031  //          : is being written is correctly stored back to the media else write operations may be unpredictable.
000861  001032        
000862  001033  func media_Init(), 1;                           // initialize uSD card
000863  001034  // Usage    : media_Init();
000864  001035  // Notes    : Initialise uSD CARD
000865  001036  //          : Response: 0 = No Card
000866  001037  //          :           1 = Card Initialised
000867  001038        
000868  001039        
000869  001040  //==============================================//
000870  001041  // RTTTL Specific Function Prototypes           //
000871  001042  //==============================================//
000872  001043        
000873  001044  func tune_Play("TunePtr"), 0;                   // play a RTTTL tune string
000874  001045  // Syntax   : tune_Play(TunePtr);
000875  001046  // Usage    : tune_Play("...notes...");
000876  001047  // Notes    : Play a tune string from a data statement or a direct string
000877  001048        
000878  001049  func tune_Pause(), 0;                           // pause RTTTL (sound continues at current note)
000879  001050  // Syntax   : tune_Pause();
000880  001051  // Usage    : tune_Pause();
000881  001052  // Notes    : Suspends any current tune from playing until a tune_Continue(),
000882  001053  //          : tune_Stop(); or a new tune_Play("...") function. The oscillator
000883  001054  //          : is not stopped
000884  001055        
000885  001056  func tune_Continue(), 0;                        // continue RTTTL
000886  001057  // Syntax   : tune_Continue();
000887  001058  // Usage    : tune_Continue();
000888  001059  // Notes    : Continues playing any previously stopped or paused tune
000889  001060        
000890  001061  func tune_Stop(), 0;                            // stop playing RTTTL tune, sound muted
000891  001062  // Syntax   : tune_Stop();
000892  001063  // Usage    : tune_Stop();
000893  001064  // Notes    : Pauses a tune and silences the oscillator until a tune_Continue(),
000894  001065  //          : tune_Stop(), tune_End or a new tune_Play("..."); function
000895  001066        
000896  001067  func tune_End(), 0;                             // cancel a RTTTL tune
000897  001068  // Syntax   : tune_End();
000898  001069  // Usage    : tune_End();
000899  001070  // Notes    : Ends any current tune and resets the tune interpreter
000900  001071        
000901  001072  func tune_Playing(), 1;                         // pol RTTTL player to see if a tune is playing
000902  001073  // Syntax   : tune_Playing();
000903  001074  // Usage    : var := tune_Playing();
000904  001075  // Notes    : returns 1 if tune is playing, 0 if no tune is playing.
000905  001076        
000906  001077  //==============================================//
000907  001078  // Communications Function Prototypes           //
000908  001079  //==============================================//
000909  001080  func com_AutoBaud("timeout"), 1;                // wait for timeout millisconds, retur baud rate if "U" received
000910  001081  // Syntax   : com_AutoBaud(timeout);
000911  001082  // Usage    : arg := com_AutoBaud(500);
000912  001083  //          : enter auto baud mode for "time" milliseconds, wait for "U"
000913  001084  //          : If timeout occurs, a 0 is returned, else the baud rate
000914  001085  //          : divisor calculated is returned for verification if required.
000915  001086        
000916  001087  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
000917  001088  // Syntax   : com_Init(buffer, bufsize, qualifier);
000918  001089  // Usage1   : com_Init(mybuf, 20, 0);
000919  001090  // Usage2   : com_Init(mybuf, 20, ':');
000920  001091  // Notes    : initialize a serial capture buffer for the comms input
000921  001092  //          : The program must declare a var array as a circular buffer.
000922  001093  //          : Usage1 declares a circular buffer which will continually
000923  001094  //          : buffer characters.
000924  001095  //          : Usage2 must receive ':' before any characters will
000925  001096  //          : accumulate in the buffer.
000926  001097        
000927  001098  func com_Reset(), 0;                            // reset the ring buffer
000928  001099  // Syntax   : com_Reset();
000929  001100  // Usage    : com_Reset();
000930  001101  // Notes    : reset comms to default polled mode
000931  001102        
000932  001103  func com_Count(), 1;                            // return count of characters in ring buffer
000933  001104  // Syntax   : com_Count();
000934  001105  // Usage    : arg := com_Count();
000935  001106  // Notes    : return count of buffered characters in buffer attachment
000936  001107        
000937  001108  func com_Full(), 1;                             // return TRUE if com buffer filled to capcity
000938  001109  // Syntax   : com_Full();
000939  001110  // Usage    : if (com_Full() ,,,, go read buffer;
000940  001111  // Notes    : return true if buffer full (not necessarily an error if buffer is sized to a packet size)
000941  001112        
000942  001113  func com_Error(), 1;                            // return TRUE if a comms error occurred
000943  001114  // Usage    : if (com_Error() ) ...... take recovery action;
000944  001115  // Notes    : Returns 1 if any low level communications error occurred, else returns 0.
000945  001116        
000946  001117  func com_Sync(), 1;                             // returns TRUE if qualifier has been received
000947  001118  // Syntax   : com_Sync();
000948  001119  // Usage    : var := com_Sync();
000949  001120  // Notes    : return true if sync character has been received in com_Init("...") mode
000950  001121        
000951  001122  func com_Checksum(), 1;                         // returns checksum if employed. 0 = OK
000952  001123  // Syntax   : com_Checksum();
000953  001124  // Usage    : if(!com_Checksum()); processMyPacket();
000954  001125  // Notes    : Transparent to normal operation, a check summing system is operating. If the host sends one extra
000955  001126  //          : character as part of the packet (usually added at the end of the packet) which is the negated value of the
000956  001127  //          : addition of all the previous characters in the packet. Once the com_Full() function reports a buffer full
000957  001128  //          : situation (ie the packet is fully received) , the checksum can be read, and should read zero if the packet
000958  001129  //          : is not corrupted.
000959  001130  //          :
000960  001131  //          : Returns 0 if checksum has been computed correctly.
000961  001132        
000962  001133  func com_PacketSize(), 1;                       // returns size of the comms buffer for packet mode
000963  001134  // Syntax   : com_PacketSize();
000964  001135  // Usage    : If (!com_Count()); print("Waiting....");
000965  001136  // Notes    : com_PacketSize() will indicate how large the packet is ONLY after the packet reception has started.
000966  001137  //          : Although it is usually not required to know the packet size until the packet has actually been read, if it
000967  001138  //          : is a requirement, the count is available as soon as com_Count() becomes non zero. If not in variable
000968  001139  //          : packet length mode, com_PacketSize() just returns the size of the specified buffer.
000969  001140  //          :
000970  001141  //          : Returns the size of a packet if in variable packet length mode, or just the size of the serial buffer if
000971  001142  //          : not variable packet length mode.
000972  001143        
000973  001144  //==============================================//
000974  001145  // Display Initialization                       //
000975  001146  // (for GOLDELOX-GFX2 with external display)    //
000976  001147  //==============================================//
000977  001148        
000978  001149  func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
000979  001150  // Syntax   : disp_Init(initTable, stateMachine);
000980  001151  // Usage    : disp_Init(INIT_tbl, GRAM_sm);
000981  001152  // Notes    : The GOLDELOX-GFX2 needs to be aware of all the display registers and how to access them.
000982  001153  //          : The initialisation and the state machine tables are necessary to achieve this. Refer to the individual
000983  001154  //          : display data sheet available from the display manufacturer.
000984  001155  //          : For hardware platform modules such as uOLED-96-G1(GFX), uOLED-128-G1(GFX), etc the disp_Init(,,) is not
000985  001156  //          : needed. The modules are factory set-up with their display specific configurations.
000986  001157  //          :
000987  001158  //          : initTable   : A reference to the device initialisation table which is stored as a data statement.
000988  001159  //          : stateMachine: A reference to the device state machine table which is stored as a data statement.
000989  001160  //          :
000990  001161        
000991  001162  //==============================================//
000992  001163  // Display Access                               //
000993  001164  //==============================================//
000994  001165        
000995  001166  func disp_WriteByte("value"), 0;                // write a data byte to the display
000996  001167  // Syntax: disp_WriteByte(value);
000997  001168  // Usage    : on a SD1339 display driver IC
000998  001169  //          : #constant DRAW_CIRCLE 0x86
000999  001170  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
001000  001171  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
001001  001172  //          :     disp_WriteByte(x);                // set x1
001002  001173  //          :     disp_WriteByte(y);                // set y1
001003  001174  //          :     disp_WriteByte(r);                // set x2
001004  001175  //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
001005  001176  //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
001006  001177  //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
001007  001178  //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
001008  001179  //          : endfunc
001009  001180  // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
001010  001181  //          : sheets for the display for more information. This function is used to extend the capabilities of the user
001011  001182  //          : code to gain access to the the display hardware.
001012  001183  //          :
001013  001184  //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
001014  001185  //          : the display.
001015  001186        
001016  001187  func disp_WriteControl("value"), 0;             // write a control byte to the display
001017  001188  // Syntax: disp_WriteControl("value");
001018  001189  // Usage    : on a SD1339 display driver IC
001019  001190  //          : #constant DRAW_CIRCLE 0x86
001020  001191  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
001021  001192  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
001022  001193  //          :     disp_WriteByte(x);                // set x1
001023  001194  //          :     disp_WriteByte(y);                // set y1
001024  001195  //          :     disp_WriteByte(r);                // set x2
001025  001196  //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
001026  001197  //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
001027  001198  //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
001028  001199  //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
001029  001200  //          : endfunc
001030  001201  // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
001031  001202  //          : sheets for the display for more information. This function is used to extend the capabilities of the user
001032  001203  //          : code to gain access to the the display hardware.
001033  001204  //          : value Specifies the value to be written to the display control register. Only the lower 8 bits are sent to
001034  001205  //          : the display.
001035  001206        
001036  001207  func disp_WriteWord("value"), 0;                // write a word (HI:LO format) to the display
001037  001208  // Syntax   : disp_WriteWord(value);
001038  001209  // Usage    : on a SD1339 display driver IC
001039  001210  //          : #constant DRAW_CIRCLE 0x86
001040  001211  //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
001041  001212  //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
001042  001213  //          :     disp_WriteByte(x);                // set x1
001043  001214  //          :     disp_WriteByte(y);                // set y1
001044  001215  //          :     disp_WriteByte(r);                // set x2
001045  001216  //          :     disp_WriteWord(linecolour);       // set outline colour
001046  001217  //          :     disp_WriteWord(fillcolour);       // set fill colour
001047  001218  //          : endfunc
001048  001219  // Notes    : Sends a 16 bit value to the display bus. Since the GOLDELOX-GFX2 display data bus is 8bits wide, the HIGH
001049  001220  //          : byte is sent first followed by the LOW byte. Refer to individual data sheets for the display for more
001050  001221  //          : information. This function is used to extend the capabilities of the user code to gain access to the the
001051  001222  //          : display hardware.
001052  001223  //          :
001053  001224  //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
001054  001225  //          : the display.
001055  001226        
001056  001227  func disp_ReadByte(), 1;                        // read a byte from the display
001057  001228  // Syntax   : disp_ReadByte();
001058  001229  // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
001059  001230  //          : gfx_FocusWindow(); // focus GRAM
001060  001231  //          : pixel_Hi:= dispReadByte(); // read hi byte of first pixel
001061  001232  //          : pixel_Lo:= dispReadByte(); // read lo byte of first pixel
001062  001233  // Notes    : Reads a byte from the display after an internal register or GRAM access has been set.
001063  001234  //          : value Returns the 8bit data that was read from the display. Only the lower 8bits are valid.
001064  001235        
001065  001236  func disp_ReadWord(), 1;                        // read a word from the display (HI:LO format)
001066  001237  // Syntax   : disp_ReadWord();
001067  001238  // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
001068  001239  //          : gfx_FocusWindow(); // focus GRAM
001069  001240  //          : pixel := dispReadWord(); // read 1st pixel, HI:LO order
001070  001241  // Notes    : Reads a 16bit word from the display after an internal register or GRAM access has been set.
001071  001242  //          : Returns the 16bit data that was read from the display.
001072  001243        
001073  001244  func disp_BlitPixelFill("colr","count"), 0;      // write "count" pixels to the display (8 or 16 bit)
001074  001245  // Syntax   : disp_BlitPixelFill(colour, count);
001075  001246  // Usage    : gfx_ClipWindow(40,40,79,79); // select a block on the display
001076  001247  //          : count := gfx_FocusWindow(); // focus GRAM
001077  001248  //          : myvar:=dispBlitPixelFill(RED,count); // paint the area red
001078  001249  // Notes    : Fills a preselected GRAM screen area with the specified colour. colour Specifies the colour for the
001079  001250  //          : fill. count Specifies the number of pixels to fill.
001080  001251  //          : The arguments can be a variable, array element, expression or constant
001081  001252        
001082  001253  func disp_BlitPixelsToMedia(), 1;               // write current clip window to the media (8 or 16 bit), return pixel count
001083  001254  // Syntax   : disp_BlitPixelsToMedia();
001084  001255  // Usage    : media_SetSector(0x0020,0x0000); // we're going to write here
001085  001256  //          : n:=disp_BlitPixelsToMedia (); // save it to sector
001086  001257  // Notes    : Write the selected GRAM area to the media at the current media address. Needs a uSD card.
001087  001258  //          : Returns the number of pixels that were written to the media.
001088  001259        
001089  001260  func disp_BlitPixelsFromCOM("mode"), 0;         // write pixels from the serial port to the currnetly focused GRAM area (8 or 16 bit)
001090  001261  // Syntax   : disp_BlitPixelFromCOM(mode);
001091  001262  // Usage    : gfx_ClipWindow(40,40,59,59); // writing to a 40x40 block on the display.
001092  001263  //          : gfx_FocusWindow(); // NB first focus is just so we can get pixel count of area.
001093  001264  //          : print("Filling ",*IMG_PIXEL_COUNT," pixels");
001094  001265  //          : gfx_FocusWindow();
001095  001266  //          : disp_BlitPixelsFromCOM(0); // get pixels from serial port,
001096  001267  //          : while(*IMG_PIXEL_COUNT); // wait till all the pixels come in
001097  001268  // Notes    : Fills a preselected GRAM screen area with the specified colour.
001098  001269  //          : mode = 0 : specifies 16 bit pixels
001099  001270  //          : mode = pointer : specifies pointer to 16 element colour lookup table for each 4bit pixel value
001100  001271  //          : The arguments can be a variable, array element, expression or constant
001101  001272        
001102  001273  func disp_BlitPixelsToCOM(), 1;                 // write current clip window to the com port (8 or 16 bit), return pixel count
001103  001274  // Syntax   : disp_BlitPixelsToCOM();
001104  001275  // Usage    : gfx_ClipWindow(40,40,44,44);  // within a small block on the display
001105  001276  //          : pixels:=gfx_FocusWindow(); // focus GRAM and get pixel count of area
001106  001277  //          : disp_BlitPixelFill(0x4142, pixels);// fill the area using ASCII values so we can read easily
001107  001278  //          : disp_BlitPixelsToCOM(); // write the pixels to the COM port
001108  001279  // Notes    : Write the selected GRAM area to the serial (COM) port..
001109  001280  //          : Returns the number of pixels that were written to the serial port.
001110  001281        
001111  001282  func disp_BlitPixelsFromMedia("count"), 0;      // write "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
001112  001283  // Syntax   : disp_BlitPixelsFromMedia(pixelcount);
001113  001284  // Usage    : media_SetAdd(0x0002, 0x3C00); // point to required area of an image
001114  001285  //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
001115  001286  // Notes    : Read the required number of pixels consecutively from the current media stream and write
001116  001287  //          : them to the current display GRAM address. For 8bit colour mode, each pixel comprises a single 8bit value.
001117  001288  //          : For 16bit colour, each pixel is composed of 2 bytes, the high order byte is read first, the low order bye
001118  001289  //          : is read next.
001119  001290  //          : pixelcount Specifying the number of pixels to be consecutively read from the media stream.
001120  001291  //          : The arguments can be a variable, array element, expression or constant
001121  001292        
001122  001293  func disp_SkipPixelsFromMedia("count"), 0;      // skip "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
001123  001294  // Syntax   : disp_SkipPixelsFromMedia("count");
001124  001295  // Usage    : disp_SkipPixelsFromMedia(20); // skip the next 20 pixels from media
001125  001296  //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
001126  001297  // Notes    : Skip the required number of pixels consecutively from the current media stream, discarding them. For 8bit
001127  001298  //          : colour mode, each pixel comprises a single 8bit value. For 16bit colour, each pixel is composed of 2
001128  001299  //          : bytes, the high order byte is read first, the low order bye is read next.
001129  001300  //          :
001130  001301  //          : pixelcount Specifying the number of pixels to be consecutively skipped from the media stream.
001131  001302  //          : The arguments can be a variable, array element, expression or constant
001132  001303        
001133  001304  //==============================================//
001134  001305  // unadorned SPI functions                      //
001135  001306  //==============================================//
001136  001307        
001137  001308  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001138  001309  // Syntax   : spi_Init(speed, input_mode, output_mode);
001139  001310  // Usage    : spi_Init(speed,ip_mode,op_mode);
001140  001311  // Notes    : Sets up the GOLDELOX-GFX2 SPI port to communicate with SPI devices.
001141  001312  //          : Note: The SPI functions in this section are not necessary when using the memory card or serial flash chips
001142  001313  //          : interfaced to the SPI port. The SPI functions in this section are relevant to those devices other than the
001143  001314  //          : memory card and the serial flash chip used for media access.
001144  001315  //          : speed         : Sets the speed of the SPI port.
001145  001316  //          : input_mode    : Sets the input mode of the SPI port.
001146  001317  //          : output_mode   : Sets the output mode of the SPI port. See diagram below.
001147  001318  //          : The arguments can be a variable, array element, expression or constant
001148  001319        
001149  001320  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001150  001321  // Syntax   : spi_Read();
001151  001322  // Usage    : var := spi_Read();
001152  001323  // Notes    : This function allows a raw unadorned byte read from the SPI device.
001153  001324  //          : Note: The Chip Select line (SDCS) is lowered automatically.
001154  001325  //          : Returns a single data byte from the SPI device.
001155  001326        
001156  001327  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001157  001328  // Syntax   : spi_Write("byte");
001158  001329  // Usage    : spi_Write(byte);
001159  001330  // Notes    : This function allows a raw unadorned byte write to the SPI device.
001160  001331  //          : Note: The Chip Select line (SDCS) is lowered automatically.
001161  001332  //          : byte specifies the data byte to be sent to the SPI device.
001162  001333        
001163  001334  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001164  001335  // Syntax   : spi_Disable();
001165  001336  // Usage    : spi_Disable();
001166  001337  // Notes    : This function raises the Chip Select (SDCS) line of the SPI device, disabling it from further activity.
001167  001338  //          : The CS line will be automatically lowered next time the SPI functions spi_Read() or spi_Write(...) are
001168  001339  //          : used, and also by action of any of the media_ functions.
001169  001340        
001170  001341        
001171  001342  //==============================================//
001172  001343  // flash device specific functions              //
001173  001344  //==============================================//
001174  001345        
001175  001346  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001176  001347  // Syntax   : flash_SIG();
001177  001348  // Usage    : var := flash_SIG();
001178  001349  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001179  001350  //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
001180  001351  //          : devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit
001181  001352  //          : (2M x 8) Serial Flash Memory.
001182  001353  //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
001183  001354  //          : byte is ignored.
001184  001355        
001185  001356  func flash_ID(), 1;                             // read ID code from FLASH device
001186  001357  // Syntax   : flash_ID();
001187  001358  // Usage    : var := flash_ID();
001188  001359  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001189  001360  //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
001190  001361  //          : The only devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to
001191  001362  //          : 32Mbit (2M x 8) Serial Flash Memory.
001192  001363  //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
001193  001364  //          : contains capacity. Refer to the device data sheet for further information.
001194  001365        
001195  001366  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001196  001367  // Syntax   : flash_BulkErase();
001197  001368  // Usage    : flash_BulkErase();
001198  001369  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001199  001370  //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
001200  001371  //          : supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8)
001201  001372  //          : Serial Flash Memory.
001202  001373  //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
001203  001374  //          : seconds depending on the size of the flash device.
001204  001375        
001205  001376  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001206  001377  // Syntax   : flash_BlockErase("block")
001207  001378  // Usage    : var := flash_BlockErase(block_num)
001208  001379  // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
001209  001380  //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
001210  001381  //          : far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8) Serial Flash
001211  001382  //          : Memory.
001212  001383  //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
001213  001384  //          : blockAddress The address of the 64k FLASH block to be erased.
001214  001385  //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
001215  001386  //          : can take up to 3 milliseconds.
001216  001387        
001217  001388  //==============================================//
001218  001389  // user stack operations                        //
001219  001390  //==============================================//
001220  001391        
001221  001392  func setsp("offset"), 0;                        // set the user stack pointer (same as pokeW(USR_SP, n); )
001222  001393  // Syntax   : setsp(index);
001223  001394  // Usage    : setsp(0); // reset the stack pointer
001224  001395  // Notes    : The users stack pointer is zeroed at power up, but it is sometimes necessary to alter the stack pointer
001225  001396  //          : for various reasons, such as running multiple concurrent stacks, or resetting to a known position as part
001226  001397  //          : of an error recovery process.
001227  001398  //          : index: This argument is used to set the users SP to the required position. The stack pointer is set to
001228  001399  //          : zero during power-up initialisation.
001229  001400        
001230  001401  func getsp(), 1;                                // return the current stack pointer (same as peekW(USR_SP); )
001231  001402  // Usage    : push(1234);
001232  001403  //          : print(getsp()); // print the stack index
001233  001404  // Notes    : This function returns the current stack index into the stack array. If the index is zero, there are no
001234  001405  //          : items on the stack.
001235  001406  //          : index: The current stack index.
001236  001407        
001237  001408  func pop(), 1;                                  // pop var off stack
001238  001409  // Syntax   : pop();
001239  001410  // Usage    : push(100);
001240  001411  //          : push(200);
001241  001412  //          : print(pop()+ pop());
001242  001413  // Notes    : This function returns the value at the current stack pointer index. The stack pointer is then
001243  001414  //          : decremented, so it now points to the item below. If the stack pointer is zero, (ie a pop was performed on
001244  001415  //          : an empty stack) the function returns 0 and the stack pointer is not altered (ie it remains at 0).
001245  001416  //          : Returns the value at current stack pointer index.
001246  001417        
001247  001418  func drop("count"), 0;                          // drop n vars off stack
001248  001419  // Syntax   : drop(count);
001249  001420  // Usage    : myvar := 10;
001250  001421  //          : push(1234);
001251  001422  //          : push(5678);
001252  001423  //          : push(myvar);
001253  001424  //          : drop(2);
001254  001425  // Notes    : Decrements the user stack pointer determined by the value n. If n exceeds the stack index, the stack
001255  001426  //          : pointer is zeroed.
001256  001427  //          : count Specifies the number of items to be dropped from the stack.
001257  001428        
001258  001429  func push("item"), 1;                           // push value to stack
001259  001430  // Syntax   : push(val);
001260  001431  // Usage    : Myvar := 10;
001261  001432  //          : push(1234);
001262  001433  //          : push(5678);
001263  001434  //          : push(myvar);
001264  001435  // Notes    : Increment the user stack pointer first and then places the item into the user stack array at the current
001265  001436  //          : position. The stack pointer is now pointing to this new item.
001266  001437  //          : val: Argument to be pushed to the user stack.
001267  001438        
001268  001439  func call(), 1;                                 // exec a function using stacked frame (frame is dropped)
001269  001440  // Syntax   : call()
001270  001441  // Usage    : push(10);
001271  001442  //          : push(10);
001272  001443  //          : push(50);
001273  001444  //          : push(50);
001274  001445  //          : push(0xFFFF);
001275  001446  //          : push(gfx_RectangleFilled); // push the function call address
001276  001447  //          : push(5); // push the argument count
001277  001448  //          : //~~~~~~~
001278  001449  //          : call();
001279  001450  // Notes    : Calls the specified function, the arguments to the called function are from the stack. The stacked
001280  001451  //          : parameters are consumed and the stack pointer is altered to match the number of arguments that were
001281  001452  //          : consumed.
001282  001453  //          : value: If the called function returns a value then it is available.
001283  001454        
001284  001455  func exec("func","argcnt"), 1;                  // exec a function using stacked parameters (parameters remain)
001285  001456  // Syntax   : exec("func","argcnt");
001286  001457  // Usage    : Push(50); // set some arbitrary values on the stack
001287  001458  //          : push(50);
001288  001459  //          : push(10);
001289  001460  //          : push(YELLOW);
001290  001461  //          : //~~~~~~~
001291  001462  //          : exec(gfx_Circle,4); // exec the circle function using the stacked parameters
001292  001463  // Notes    : Calls the specified function, passing the arguments to the called function from the stack. The stack and
001293  001464  //          : stack pointer are not altered.
001294  001465  //          : functionPtr A pointer to a function which will utilise the stacked arguments. argCount The count of
001295  001466  //          : arguments on the stack that are to be passed to the function call.
001296  001467  //          : The arguments can be a variable, array element, expression or constant.
001297  001468        
001298  001469  //==============================================//
001299  001470  // size modifier                                //
001300  001471  //==============================================//
001301  001472        
001302  001473  func iterator("offset"), 0;                     // set the iterator size for ++/-- (same as pokeW(INCVAL, n);
001303  001474  // Syntax   : iterator("offset");
001304  001475  // Usage    : iterator(arg);
001305  001476  // Notes    :
001306  001477        
001307  001478  //==============================================//
001308  001479  // string and character size function           //
001309  001480  //==============================================//
001310  001481        
001311  001482  func strlen("pointer"), 1;                      // return length of a string in character units
001312  001483  // Syntax   : strlen("pointer");
001313  001484  // Usage    : var := strlen(Str);
001314  001485  // Notes    : strlen returns the length of a zero terminated string in character units. Note that any string constants
001315  001486  //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
001316  001487  //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
001317  001488  //          : function to work correctly.
001318  001489  //          : pointer: The pointer to a zero (0x00) terminated string.
001319  001490  //          : Returns the length of a string in character units.
001320  001491        
001321  001492  func charwidth("char"), 1;                          // return width of a character in pixel units
001322  001493  // Syntax   : charwidth("char");
001323  001494  // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
001324  001495  //          : w := charwidth('W');  // get a characters width
001325  001496  // Notes    : charwidth is used to calculate the width in pixel units for a string, based on the currently selected
001326  001497  //          : font. The font can be proportional or mono-spaced. If the total width of the string exceeds 255 pixel
001327  001498  //          : units, the function will return the 'wrapped' (modulo 8) value.
001328  001499  //          : char: The ascii character for the width calculation.
001329  001500  //          : Returns the width of a single character in pixel units.
001330  001501        
001331  001502  func charheight("char"), 1;                         // return height of a character in pixel units
001332  001503  // Syntax   : charheight("char");
001333  001504  // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
001334  001505  //          : w := charheight('W'); // get a characters width
001335  001506  // Notes    : charheight is used to calculate the height in pixel units for a string, based on the currently selected
001336  001507  //          : font. The font can be proportional or mono-spaced.
001337  001508  //          : char: The ascii character for the height calculation.
001338  001509  //          : Returns the height of a single character in pixel units.
001339  001510        
001340  001511  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001341  001512  // Syntax   : strwidth("pointer");
001342  001513  // Usage    : var := strwidth(Str);
001343  001514  // Notes    : strwidth returns the width of a zero terminated string in pixel units. Note that any string constants
001344  001515  //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
001345  001516  //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
001346  001517  //          : function to work correctly.
001347  001518  //          : pointer: The pointer to a zero (0x00) terminated string.
001348  001519  //          : Returns the width of a string in pixel units.
001349  001520        
001350  001521  func strheight(), 1;                            // return height of a string in pixel units
001351  001522  // Syntax   : strheight(Str);
001352  001523  // Usage    : var := strheight();
001353  001524  // Notes    : strheight returns the height of a zero terminated string in pixel units. The strwidth function must be
001354  001525  //          : called first which makes available width and height. Note that any string constants declared in your
001355  001526  //          : program are automatically terminated with a zero as an end marker by the compiler. Any string that you
001356  001527  //          : create in the DATA section or MEM section must have a zero added as a terminator for this function to work
001357  001528  //          : correctly.
001358  001529  //          : Returns the height of a string in pixel units.
001359  001530        
001360  001531  //==============================================//
001361  001532  // extended functions                           //
001362  001533  //==============================================//
001363  001534        
001364  001535  func EVE_SP(), 1;                               // current EVE stack pointer
001365  001536  // Syntax   : EVE_SP();
001366  001537  // Usage    : var := EVE_SP();
001367  001538  // Notes    : returns the EVE stack pointer, useful for fault finding
001368  001539  //          : and checking for stack limits. Eve stack is 0x300 to 0x3FF
001369  001540  //          : Your application should not take stack above 0x3C0 to allow
001370  001541  //          : room for internal use.
001371  001542        
001372  001543        
001373  001544  //==============================================//
001374  001545  // Single parameter short-cuts                  //
001375  001546  // for the txt_Set functions                    //
001376  001547  //==============================================//
001377  001548        
001378  001549  func txt_FGcolour("colour"), 0;                 // 0  text foreground colour
001379  001550  // Syntax   : txt_FGcolour("colour")
001380  001551  // Usage    : txt_FGcolour(colr);
001381  001552  // Notes    : Change text foreground color
001382  001553        
001383  001554  func txt_BGcolour("colour"), 0;                 // 1  text background colour
001384  001555  // Syntax   : txt_BGcolour("colour");
001385  001556  // Usage    : txt_BGcolour(colr);
001386  001557  // Notes    : Change text background color
001387  001558        
001388  001559  func txt_FontID("id"), 0;                       // 2  text font ID (0 = system font)
001389  001560  // Syntax   : txt_FontID("id");
001390  001561  // Usage    : txt_FontID(font_num);
001391  001562  // Notes    : Set font type
001392  001563        
001393  001564  func txt_Width("multiplier"), 0;                // 3  text width multiplier
001394  001565  // Syntax   : txt_Width("multiplier");
001395  001566  // Usage    : txt_Width(arg);
001396  001567  // Notes    : Multiply the text width by x times.
001397  001568        
001398  001569  func txt_Height("multiplier"), 0;               // 4  text height multiplier
001399  001570  // Syntax   : txt_Height("multiplier");
001400  001571  // Usage    : txt_Height(arg);
001401  001572  // Notes    :  Multiply the text height by x times.
001402  001573        
001403  001574  func txt_Xgap("pixelcount"), 0;                 // 5  text gap between characters
001404  001575  // Syntax   : txt_Xgap("pixelcount");
001405  001576  // Usage    : txt_Xgap(arg);
001406  001577  // Notes    : Set gap between two consecutive characters
001407  001578        
001408  001579  func txt_Ygap("pixelcount"), 0;                 // 6  text gap between lines
001409  001580  // Syntax   : txt_Ygap("pixelcount");
001410  001581  // Usage    : txt_Ygap(arg);
001411  001582  // Notes    : Set gap between two consecutive rows of characters
001412  001583        
001413  001584  func txt_Delay("millisecs"), 0;                 // 7  text printing delay factor
001414  001585  // Syntax   : txt_Delay("millisecs");
001415  001586  // Usage    : txt_Delay(arg);
001416  001587  // Notes    : Text printing delay
001417  001588        
001418  001589  func txt_Opacity("mode"), 0;                    // 8  text OPAQUE or TRANSPARENT
001419  001590  // Syntax   : txt_Opacity("mode");
001420  001591  // Usage    : txt_Opacity(arg);
001421  001592  // Notes    : Set text to be opaque or transparent
001422  001593  //          : 0 for opaque
001423  001594  //          : 1 for transparent
001424  001595        
001425  001596  func txt_Bold("mode"), 0;                       // 9  text bold ON/OFF
001426  001597  // Syntax   : txt_Bold("mode");
001427  001598  // Usage    : txt_Bold(arg);
001428  001599  // Notes    : Set bold text on or off
001429  001600  //          : 0 bold off
001430  001601  //          : 1 bold on
001431  001602        
001432  001603  func txt_Italic("mode"), 0;                     // 10 text italic ON/OFF
001433  001604  // Syntax   : txt_Italic("mode");
001434  001605  // Usage    : txt_Italic(arg);
001435  001606  // Notes    : Set Itallic text on or off
001436  001607  //          : 0 Itallic off
001437  001608  //          : 1 Itallic on
001438  001609        
001439  001610  func txt_Inverse("mode"), 0;                    // 11 text inverse ON/OFF
001440  001611  // Syntax   : txt_Inverse("mode");
001441  001612  // Usage    : txt_Inverse(arg);
001442  001613  // Notes    : Set inverse text on or off
001443  001614  //          : 0 Inverse off
001444  001615  //          : 1 Inverse on
001445  001616        
001446  001617  func txt_Underline("mode"), 0;                  // 12 text underline ON/OFF
001447  001618  // Syntax   : txt_Underline("mode");
001448  001619  // Usage    : txt_Underline(arg);
001449  001620  // Notes    : Set Underline text on or off
001450  001621  //          : 0 Underlining off
001451  001622  //          : 1 Underlining on
001452  001623        
001453  001624  func txt_Attributes("value"), 0;                // 13 text combined bold|italic|inverse|underline
001454  001625  // Syntax   : txt_Attributes("value");
001455  001626  // Usage    : txt_Attributes(arg);
001456  001627  // Notes    : text combined bold|italic|inverse|underline, enabled or disabled simultaneously
001457  001628  //          : 0 : bold|italic|inverse|underline disabled
001458  001629        
001459  001630  func _1E(), 0;                                  // 14 text reserved
001460  001631  func _1F(), 0;                                  // 15 text reserved
001461  001632        
001462  001633  //==============================================//
001463  001634  // Single parameter short-cuts                  //
001464  001635  // for the gfx_Set functions                    //
001465  001636  //==============================================//
001466  001637        
001467  001638  func gfx_PenSize("mode"), 0;                    // 0  graphics pen size, SOLD or OUTLINE
001468  001639  // Syntax   : gfx_PenSize("mode");
001469  001640  // Usage    : gfx_PenSize("mode");
001470  001641  // Notes    : Set pen size.
001471  001642  //          : 0 Solid object
001472  001643  //          : 1 Outline object
001473  001644        
001474  001645  func gfx_BGcolour("colour"), 0;                 // 1  graphics background colour
001475  001646  // Syntax   : gfx_BGcolour("colour");
001476  001647  // Usage    : gfx_BGcolour(colr");
001477  001648  // Notes    : Sets background color of the screen
001478  001649  //          : value = 0 to 0xFFFF, Black to White
001479  001650        
001480  001651  func gfx_ObjectColour("colour"), 0;             // 2  graphics object colour
001481  001652  // Syntax   : gfx_ObjectColour("colour");
001482  001653  // Usage    : gfx_ObjectColour(colr);
001483  001654  // Notes    : Sets the Object colour used in various functions
001484  001655  //          : value = 0 to 0xFFFF, Black to White
001485  001656  //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
001486  001657        
001487  001658  func gfx_Clipping("mode"), 0;                   // 3  graphics clipping ON/OFF
001488  001659  // Syntax   : gfx_Clipping("mode");
001489  001660  // Usage    : gfx_Clipping("mode");
001490  001661  // Notes    : Set clipping mode
001491  001662  //          : 0 : Clipping disabled
001492  001663  //          : 1 : Clipping enabled
001493  001664        
001494  001665  func gfx_TranparentColour("colour"), 0;         // 4  graphics image transparent mask colour
001495  001666  // Syntax   : gfx_TranparentColour("colour");
001496  001667  // Usage    : gfx_TranparentColour("colr");
001497  001668  // Notes    : Sets Bitmap, Image or Animation Transparency Colour
001498  001669  //          : value = 0 to 0xFFFF Black to White
001499  001670        
001500  001671  func gfx_Tranparency("mode"), 0;                // 5  graphics image transparent mode ON/OFF
001501  001672  // Syntax   : gfx_Tranparency("mode");
001502  001673  // Usage    : gfx_Tranparency("mode");
001503  001674  // Notes    : Enables/Disables the Transparency feature
001504  001675  //          : 0 : Transparency disabled
001505  001676  //          : 1 : Transparency enabled
001506  001677        
001507  001678  func gfx_FrameDelay("milliseconds"), 0;         // 6  graphics animation frame delay
001508  001679  // Syntax   : gfx_FrameDelay("milliseconds");
001509  001680  // Usage    : gfx_FrameDelay(arg);
001510  001681  // Notes    : Sets the Video/Animation clip inter-frame delay for uSD_Video function.
001511  001682  //          : This setting will over-ride the embedded frame delay of the clip. After the event, the setting will autodisable, and
001512  001683  //          : if further inter-frame delays need overriding the setting must be reissued.
001513  001684  //          : This function will not control frame delays for a image control, refer to image control.
001514  001685  //          : value = 0 to 255 ms
001515  001686        
001516  001687  func gfx_ScreenMode("mode"), 0;                 // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001517  001688  // Usage    : gfx_ScreenMode(LANDSCAPE);
001518  001689  // Notes    : Set display orientation
001519  001690  //          : value = 1 : LANDSCAPE
001520  001691  //          : value = 2 : LANDSCAPE_R (Rotated)
001521  001692  //          : value = 3 : PORTRAIT
001522  001693  //          : value = 4 : PORTRAIT_R (Rotated)
001523  001694        
001524  001695  func gfx_OutlineColour("colour"), 0;            // 8  graphics rectangle/circle outline colour
001525  001696  // Syntax   : gfx_OutlineColour("colour");
001526  001697  // Usage    : gfx_OutlineColour(colr");
001527  001698  // Notes    : Sets the solid Rectangle or Circle objects outline colour.
001528  001699  //          : value = 0 : Disables this feature
001529  001700  //          : value = 1 to 0xFFFF : is the effective range
001530  001701        
001531  001702  func gfx_Contrast("value"), 0;                  // 9  graphics hardware contrast value 0-16 (0=off) *** only on internal driver devices
001532  001703  // Usage    : gfx_Contrast(val);
001533  001704  // Notes    : Set the display contrast
001534  001705  //          : 0 Display in low power mode. Display retains its contents in low power mode
001535  001706  //          : 1-16 Display on 1 = lowest, 16 = highest
001536  001707        
001537  001708  func gfx_LinePattern("value"), 0;               // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001538  001709  // Syntax   : gfx_LinePattern("value");
001539  001710  // Usage    : gfx_LinePattern(val);
001540  001711  // Notes    : Sets the line draw pattern for line drawing. If set to zero, lines are solid, else eac '1' bit represents
001541  001712  //          : a pixel that is turned off.
001542  001713  //          : 0 bits for pixels on
001543  001714  //          : 1 bits for pixels off
001544  001715        
001545  001716  func gfx_ColourMode("mode"), 0;                 // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001546  001717  // Syntax   : gfx_ColourMode("mode");
001547  001718  // Usage    : gfx_ColourMode(mod);
001548  001719  // Notes    : Set Graphics Colour mode
001549  001720  //          : COLOUR8  : 8bit colours
001550  001721  //          : COLOUR16 : 16bit colours
001551  001722        
001552  001723  //==============================================//
001553  001724  func _2C(), 0;                                  // 12 graphics  reserved
001554  001725  func _2D(), 0;                                  // 13 graphics  reserved
001555  001726  func _2E(), 0;                                  // 14 graphics  reserved
001556  001727  func _2F(), 0;                                  // 15 graphics  reserved
001557  001728  //==============================================//
001558  001729        
001559  001730        
001560  001731  //==============================================//
001561  001732  // generic constants                            //
001562  001733  //==============================================//
001563  001734  #CONST
001564  001741  #END
001565  001742        
001566  001743  //==============================================//
001567  001744  // joystick() function return constants         //
001568  001745  //==============================================//
001569  001746  #CONST
001570  001753  #END
001571  001754        
001572  001755  //==============================================//
001573  001756  // spi_Init(...)  mode arguments                //
001574  001757  //==============================================//
001575  001758  #CONST
001576  001768  #END
001577  001769        
001578  001770  //==============================================//
001579  001771  //Pin related constants                         //
001580  001772  //==============================================//
001581  001773  #CONST
001582  001784  #END
001583  001785        
001584  001786  //==============================================//
001585  001787  //gfx_Set() related constants                   //
001586  001788  //==============================================//
001587  001789  #CONST
001588  001802  #END
001589  001803        
001590  001804        
001591  001805  #CONST
001592  001816  #END
001593  001817        
001594  001818  //==============================================//
001595  001819  //txt_Set() related constants                   //
001596  001820  //==============================================//
001597  001821  #CONST
001598  001836  #END
001599  001837        
001600  001838  //==============================================//
001601  001839  //txt_Set() related arguments                   //
001602  001840  //==============================================//
001603  001841  #CONST
001604  001853  #END
001605  001854        
001606  001855        
001607  001856  //==============================================//
001608  001857  // Memory MAP                                   //
001609  001858  // system BYTE variables accesible with         //
001610  001859  // peekB and pokeB                              //
001611  001860  //==============================================//
001612  001861  #CONST
001613  001897  #END
001614  001898        
001615  001899        
001616  001900  //==============================================//
001617  001901  // system WORD variables accesible with peekW   //
001618  001902  // and pokeW or pointer access                  //
001619  001903  //==============================================//
001620  001904  #CONST
001621  001950  #END
001622  001951        
001623  001952  //==============================================//
001624  001953  // bit constants for SYS_FLAGS1                 //
001625  001954  //==============================================//
001626  001955  #CONST //SYS_FLAGS1
001627  001972  #END
001628  001973        
001629  001974  //==============================================//
001630  001975  // bit constants for SYS_FLAGS2                 //
001631  001976  //==============================================//
001632  001977  #CONST // SYS_FLAGS2
001633  001994  #END
001634  001995        
001635  001996        
001636  001997  //==============================================//
001637  001998  // EVE User Resources                           //
001638  001999  //==============================================//
001639  002000  #CONST
001640  002004  #END
001641  002005        
001642  002006  //------------------------------------------------------------------------------
001643  002007  //------------------------------------------------------------------------------
001644  002008  //------------------------------------------------------------------------------
001645  002009  //------------------------------------------------------------------------------
001646  002010  //------------------------------------------------------------------------------
001647  002011        
001648  002012        
001649  002013        
001650  002014        
001651  002015        
001652  002016        
001653  002017        
001654  002018        
001655  002019        
001656  002020        
001657  000002        
001658  000003  // Program Skeleton 1.0 generated 23/03/2016 14:21:52
001659  000004        
001660  000005        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\ledDigitsDisplayGoldelox.inc

001661  000006  #inherit "ledDigitsDisplayGoldelox.inc"
001662  000006  #inherit "ledDigitsDisplayGoldelox.inc"
001663  000001  // WARNING, this code will crash if newval exceeds maximum displayable number
001664  000002  func ledDigitsDisplay(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001665  000003      var i, k, l, lb ;
001666  000004      l := 1 ;
001667  000005      for (i := 1; i < Digits; i++)
001668  000006          l *= 10 ;
001669  000007      next
001670  000008      lb := LeadingBlanks ;
001671  000009      for (i := 0; i < Digits; i++)
001672  000010          k := newval / l ;
001673  000011          newval -= k * l ;
001674  000012          if ( lb && (i < Digits - MinDigits) )
001675  000013              if (k == 0)
001676  000014                  k := 10 ;
001677  000015              else
001678  000016                  lb := 0 ;
001679  000017              endif
001680  000018          endif
001681  000019          l /= 10 ;
001682  000020          media_SetAdd(indexH, indexL) ;
001683  000021          media_VideoFrame(left+i*WidthDigit, top, k) ;
001684  000022      next
001685  000023  endfunc
001686  000024        
001687  000025  func ledDigitsDisplayD(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001688  000026      var i, k, l, lb ;
001689  000027      l := 1 ;
001690  000028      for (i := 1; i < Digits; i++)
001691  000029          l *= 10 ;
001692  000030      next
001693  000031      lb := LeadingBlanks ;
001694  000032      for (i := 0; i < Digits; i++)
001695  000033          k := newval / l ;
001696  000034          newval -= k * l ;
001697  000035          if ( lb && (i < Digits - MinDigits) )
001698  000036              if (k == 0)
001699  000037                  k := 10 ;
001700  000038              else
001701  000039                  lb := 0 ;
001702  000040              endif
001703  000041          endif
001704  000042          l /= 10 ;
001705  000043          media_SetAdd(indexH, indexL) ;
001706  000044          media_VideoFrame(left-i*WidthDigit+(Digits-1)*WidthDigit+6, top, k) ;
001707  000045      next
001708  000046  endfunc
001709  000047        
001710  000048  func ledDigitsDisplayR(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001711  000049      var i, k, l, lb ;
001712  000050      l := 1 ;
001713  000051      for (i := 1; i < Digits; i++)
001714  000052          l *= 10 ;
001715  000053      next
001716  000054      lb := LeadingBlanks ;
001717  000055      for (i := 0; i < Digits; i++)
001718  000056          k := newval / l ;
001719  000057          newval -= k * l ;
001720  000058          if ( lb && (i < Digits - MinDigits) )
001721  000059              if (k == 0)
001722  000060                  k := 10 ;
001723  000061              else
001724  000062                  lb := 0 ;
001725  000063              endif
001726  000064          endif
001727  000065          l /= 10 ;
001728  000066          media_SetAdd(indexH, indexL) ;
001729  000067          media_VideoFrame(left, top-i*WidthDigit+(Digits-1)*WidthDigit+6,k) ;
001730  000068      next
001731  000069  endfunc
001732  000070        
001733  000071  func ledDigitsDisplayL(var newval, var indexH, var indexL, var left, var top, var Digits, var MinDigits, var WidthDigit, var LeadingBlanks)
001734  000072      var i, k, l, lb ;
001735  000073      l := 1 ;
001736  000074      for (i := 1; i < Digits; i++)
001737  000075          l *= 10 ;
001738  000076      next
001739  000077      lb := LeadingBlanks ;
001740  000078      for (i := 0; i < Digits; i++)
001741  000079          k := newval / l ;
001742  000080          newval -= k * l ;
001743  000081          if ( lb && (i < Digits - MinDigits) )
001744  000082              if (k == 0)
001745  000083                  k := 10 ;
001746  000084              else
001747  000085                  lb := 0 ;
001748  000086              endif
001749  000087          endif
001750  000088          l /= 10 ;
001751  000089          media_SetAdd(indexH, indexL) ;
001752  000090          media_VideoFrame(left, top+i*WidthDigit,k) ;
001753  000091      next
001754  000092  endfunc
001755  000093        
001756  000007        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

001757  000008  #inherit "4DGL_16bitColours.fnc"
001758  000008  #inherit "4DGL_16bitColours.fnc"
001759  000004  */
001760  000005        
001761  000006        
001762  000007        
001763  000008  #CONST
001764  000149  #END
001765  000150        
001766  000009        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

001767  000010  #inherit "VisualConst.inc"
001768  000010  #inherit "VisualConst.inc"
001769  000001  // Line Patterns
001770  000002  #constant  LPCOARSE    0xF0F0
001771  000002  #constant  LPCOARSE    0xF0F0
001772  000003  #constant  LPMEDIUM    0x3333
001773  000003  #constant  LPMEDIUM    0x3333
001774  000004  #constant  LPFINE      0xAAAA
001775  000004  #constant  LPFINE      0xAAAA
001776  000005  #constant  LPDASHDOT   0x03CF
001777  000005  #constant  LPDASHDOT   0x03CF
001778  000006  #constant  LPDASHDOTDOT 0x0333
001779  000006  #constant  LPDASHDOTDOT 0x0333
001780  000007  #constant  LPSOLID     0x0000
001781  000007  #constant  LPSOLID     0x0000
001782  000011        
file D:\iCubHardware\trunk\electronics\private\P2015_06_BAT\SW\Display\V1\BAT_display.4DWork\BAT_displayConst.inc

001783  000012  #inherit "BAT_displayConst.inc"
001784  000012  #inherit "BAT_displayConst.inc"
001785  000001  // File generated 24/03/2016 10:41:00
001786  000002  // Warning! This is a generated file, any manual changes will be
001787  000003  // lost during the next generation.
001788  000004        
001789  000005  // object indexes for Inputs, Image Addresses + Input Array
001790  000006  #CONST
001791  000022  #END
001792  000023        
001793  000024        
001794  000013        
001795  000014  func main()
001796  000015       var voltage, button;
001797  000016        
001798  000017        
001799  000018  //  Uncomment the following if uSD images, fonts or strings used.
001800  000019        
001801  000020      print("Starting\n") ;
001802  000021      while(!media_Init())
001803  000022          putstr("Drive not mounted...");
001804  000023          pause(200);
001805  000024          gfx_Cls();
001806  000025          pause(200);
001807  000026      wend
001808  000027        
001809  000028        
001810  000029        
001811  000030       // Customdigits1 1.1 generated 23/03/2016 16:31:19
001812  000031      media_SetAdd(iCustomdigits1H, iCustomdigits1L) ;      // point to the Customdigits1 image
001813  000032      media_Image(68, 80) ;                                 // show all digits at 0, only do this once
001814  000033        
001815  000034      // Customdigits2 1.1 generated 23/03/2016 16:31:19
001816  000035      media_SetAdd(iCustomdigits2H, iCustomdigits2L) ;      // point to the Customdigits2 image
001817  000036      media_Image(72, 100) ;                                 // show all digits at 0, only do this once
001818  000037        
001819  000038        
001820  000039        
001821  000040      voltage := 0 ;
001822  000041      button := 0;
001823  000042        
001824  000043      repeat
001825  000044        
001826  000045      pause(200);
001827  000046      voltage++;
001828  000047      if(voltage > 100)    voltage:=0;
001829  000048        
001830  000049      button++;
001831  000050      if(button > 1)     button:=0;
001832  000051        
001833  000052      // CPU 1.0 generated 23/03/2016 16:31:19
001834  000053      media_SetAdd(iCPUH, iCPUL) ;      // point to the CPU image
001835  000054      media_VideoFrame(16, 112, button) ;      // where numx is 0 (Off) or 1 (On)
001836  000055        
001837  000056      // Motors 1.0 generated 23/03/2016 16:31:19
001838  000057      media_SetAdd(iMotorsH, iMotorsL) ;      // point to the Motors image
001839  000058      media_VideoFrame(64, 112, button) ;      // where numx is 0 (Off) or 1 (On)
001840  000059        
001841  000060      // Charge 1.0 generated 23/03/2016 16:31:19
001842  000061      media_SetAdd(iChargeH, iChargeL) ;      // point to the Charge image
001843  000062      media_VideoFrame(0, 0, voltage) ;          // where numx is 0 to 100 (for a displayed 0 to 100)
001844  000063        
001845  000064      // Customdigits1 1.1 generated 23/03/2016 16:31:19
001846  000065      //media_SetAdd(iCustomdigits1H, iCustomdigits1L) ;      // point to the Customdigits1 image
001847  000066      //media_Image(68, 80) ;                                 // show all digits at 0, only do this once
001848  000067      ledDigitsDisplay(voltage, iiCustomdigits1H, iiCustomdigits1L, 68, 80, 3, 1, 9, 0) ;
001849  000068        
001850  000069      // Customdigits2 1.1 generated 23/03/2016 16:31:19
001851  000070      //media_SetAdd(iCustomdigits2H, iCustomdigits2L) ;      // point to the Customdigits2 image
001852  000071      //media_Image(72, 100) ;                                 // show all digits at 0, only do this once
001853  000072      ledDigitsDisplay(voltage, iiCustomdigits2H, iiCustomdigits2L, 72, 100, 4, 1, 9, 0) ;
001854  000073        
001855  000074        
001856  000075        
001857  000076        
001858  000077        
001859  000078        
001860  000079        
001861  000080      forever
001862  000081  endfunc
001863  000082        
Notice: no execution path to func 'ledDigitsDisplayL'
Notice: no execution path to func 'ledDigitsDisplayR'
Notice: no execution path to func 'ledDigitsDisplayD'


Symbol Table:
name                             decimal         hex
_1E                                 -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
_1F                                 -144  0xffffff70 (PmmC func) args[0] r=0  (not used)
_2C                                 -157  0xffffff63 (PmmC func) args[0] r=0  (not used)
_2D                                 -158  0xffffff62 (PmmC func) args[0] r=0  (not used)
_2E                                 -159  0xffffff61 (PmmC func) args[0] r=0  (not used)
_2F                                 -160  0xffffff60 (PmmC func) args[0] r=0  (not used)
__MAXMEM                             255  0x000000ff (const dword)  (usage 1)
__MAXPROG                           9216  0x00002400 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
_BOLD                                 16  0x00000010 (const dword)  (not used)
_CLIPPING                            256  0x00000100 (const dword)  (not used)
_COLOUR8                           16384  0x00004000 (const dword)  (not used)
_COMMINT                            4096  0x00001000 (const dword)  (not used)
_DISP16                            16384  0x00004000 (const dword)  (not used)
_DUMMY16                            8192  0x00002000 (const dword)  (not used)
_INVERSE                              64  0x00000040 (const dword)  (not used)
_ITALIC                               32  0x00000020 (const dword)  (not used)
_MEDIA_INSTALLED                       1  0x00000001 (const dword)  (not used)
_MEDIA_READ                            4  0x00000004 (const dword)  (not used)
_MEDIA_TYPE                            2  0x00000002 (const dword)  (not used)
_MEDIA_WRITE                           8  0x00000008 (const dword)  (not used)
_MEDIAFONT                         32768  0x00008000 (const dword)  (not used)
_MEDIAMODE                          4096  0x00001000 (const dword)  (not used)
_OPACITY                               4  0x00000004 (const dword)  (not used)
_OUTLINED                              8  0x00000008 (const dword)  (not used)
_OW_PIN                               16  0x00000010 (const dword)  (not used)
_PATTERNED                          8192  0x00002000 (const dword)  (not used)
_PENSIZE                               2  0x00000002 (const dword)  (not used)
_PROPFONT                          32768  0x00008000 (const dword)  (not used)
_PTR_TYPE                             32  0x00000020 (const dword)  (not used)
_RUNFLAG                            1024  0x00000400 (const dword)  (not used)
_RUNMODE                             256  0x00000100 (const dword)  (not used)
_SERMODE                            1024  0x00000400 (const dword)  (not used)
_SIGNED                              512  0x00000200 (const dword)  (not used)
_SINGLESTEP                         2048  0x00000800 (const dword)  (not used)
_STREAMLOCK                            1  0x00000001 (const dword)  (not used)
_STRMODE                             512  0x00000200 (const dword)  (not used)
_TEMP1                                64  0x00000040 (const dword)  (not used)
_TEMP2                               128  0x00000080 (const dword)  (not used)
_TXTMODE                            2048  0x00000800 (const dword)  (not used)
_UNDERLINED                          128  0x00000080 (const dword)  (not used)
ABS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ANALOGUE_10                            3  0x00000003 (const dword)  (not used)
ANALOGUE_8                             2  0x00000002 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                      1  0x00000001 (const dword)  (not used)
BAUD_110                           27271  0x00006a87 (const dword)  (not used)
BAUD_115200                           25  0x00000019 (const dword)  (not used)
BAUD_1200                           2499  0x000009c3 (const dword)  (not used)
BAUD_128000                           22  0x00000016 (const dword)  (not used)
BAUD_14400                           207  0x000000cf (const dword)  (not used)
BAUD_19200                           155  0x0000009b (const dword)  (not used)
BAUD_2400                           1249  0x000004e1 (const dword)  (not used)
BAUD_256000                           11  0x0000000b (const dword)  (not used)
BAUD_300                            9999  0x0000270f (const dword)  (not used)
BAUD_300000                           10  0x0000000a (const dword)  (not used)
BAUD_31250                            95  0x0000005f (const dword)  (not used)
BAUD_375000                            8  0x00000008 (const dword)  (not used)
BAUD_38400                            77  0x0000004d (const dword)  (not used)
BAUD_4800                            624  0x00000270 (const dword)  (not used)
BAUD_500000                            6  0x00000006 (const dword)  (not used)
BAUD_56000                            53  0x00000035 (const dword)  (not used)
BAUD_57600                            51  0x00000033 (const dword)  (not used)
BAUD_600                            4999  0x00001387 (const dword)  (not used)
BAUD_600000                            4  0x00000004 (const dword)  (not used)
BAUD_9600                            312  0x00000138 (const dword)  (not used)
beep                                 -38  0xffffffda (PmmC func) args[2] r=0  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
bits_Clear                           -15  0xfffffff1 (PmmC func) args[2] r=0  (not used)
bits_Flip                            -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
bits_Set                             -14  0xfffffff2 (PmmC func) args[2] r=0  (not used)
bits_Test                            -17  0xffffffef (PmmC func) args[2] r=1  (not used)
BLACK                                  0  0x00000000 (const dword)  (not used)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
call                                -120  0xffffff88 (PmmC func) args[0] r=1  (not used)
charheight                          -125  0xffffff83 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -124  0xffffff84 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
CLIP_BOTTOM                          147  0x00000093 (const dword)  (not used)
CLIP_BOTTOM_POS                      143  0x0000008f (const dword)  (not used)
CLIP_LEFT                            144  0x00000090 (const dword)  (not used)
CLIP_LEFT_POS                        140  0x0000008c (const dword)  (not used)
CLIP_RIGHT                           146  0x00000092 (const dword)  (not used)
CLIP_RIGHT_POS                       142  0x0000008e (const dword)  (not used)
CLIP_TOP                             145  0x00000091 (const dword)  (not used)
CLIP_TOP_POS                         141  0x0000008d (const dword)  (not used)
CLIPPING                               3  0x00000003 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           11  0x0000000b (const dword)  (not used)
COM0                               65284  0x0000ff04 (const dword)  (not used)
com_AutoBaud                         -86  0xffffffaa (PmmC func) args[1] r=1  (not used)
com_Checksum                         -93  0xffffffa3 (PmmC func) args[0] r=1  (not used)
com_Count                            -89  0xffffffa7 (PmmC func) args[0] r=1  (not used)
com_Error                            -91  0xffffffa5 (PmmC func) args[0] r=1  (not used)
com_Full                             -90  0xffffffa6 (PmmC func) args[0] r=1  (not used)
com_Init                             -87  0xffffffa9 (PmmC func) args[3] r=0  (not used)
com_PacketSize                       -94  0xffffffa2 (PmmC func) args[0] r=1  (not used)
com_Reset                            -88  0xffffffa8 (PmmC func) args[0] r=0  (not used)
com_Sync                             -92  0xffffffa4 (PmmC func) args[0] r=1  (not used)
CONTRAST                               9  0x00000009 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -23  0xffffffe9 (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
D:\iCubHardware\trunk\electronics\private\P2015_06_BAT\SW\Display\V1\BAT_display.4Dg    2803  0x00000af3 (const ??? 0)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
disp_BlitPixelFill                  -101  0xffffff9b (PmmC func) args[2] r=0  (not used)
disp_BlitPixelsFromCOM              -103  0xffffff99 (PmmC func) args[1] r=0  (not used)
disp_BlitPixelsFromMedia            -105  0xffffff97 (PmmC func) args[1] r=0  (not used)
disp_BlitPixelsToCOM                -104  0xffffff98 (PmmC func) args[0] r=1  (not used)
disp_BlitPixelsToMedia              -102  0xffffff9a (PmmC func) args[0] r=1  (not used)
disp_Init                            -95  0xffffffa1 (PmmC func) args[2] r=0  (not used)
disp_ReadByte                        -99  0xffffff9d (PmmC func) args[0] r=1  (not used)
disp_ReadWord                       -100  0xffffff9c (PmmC func) args[0] r=1  (not used)
disp_SkipPixelsFromMedia            -106  0xffffff96 (PmmC func) args[1] r=0  (not used)
disp_WriteByte                       -96  0xffffffa0 (PmmC func) args[1] r=0  (not used)
disp_WriteControl                    -97  0xffffff9f (PmmC func) args[1] r=0  (not used)
disp_WriteWord                       -98  0xffffff9e (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   3  0x00000003 (const dword)  (not used)
drop                                -118  0xffffff8a (PmmC func) args[1] r=0  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -128  0xffffff80 (PmmC func) args[0] r=1  (not used)
exec                                -121  0xffffff87 (PmmC func) args[2] r=1  (not used)
FALSE                                  0  0x00000000 (const dword)  (not used)
FIRE                                   5  0x00000005 (const dword)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -114  0xffffff8e (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -113  0xffffff8f (PmmC func) args[0] r=0  (not used)
flash_ID                            -112  0xffffff90 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -111  0xffffff91 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT_HEIGHT                          152  0x00000098 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_MAX                             149  0x00000095 (const dword)  (not used)
FONT_OFFSET                          150  0x00000096 (const dword)  (not used)
FONT_TYPE                            148  0x00000094 (const dword)  (not used)
FONT_WIDTH                           151  0x00000097 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                            6  0x00000006 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
getsp                               -116  0xffffff8c (PmmC func) args[0] r=1  (not used)
GFX_BACK_COLOUR                       86  0x00000056 (const dword)  (not used)
gfx_BGcolour                        -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
GFX_BOTTOM                            99  0x00000063 (const dword)  (not used)
gfx_BoxTo                            -64  0xffffffc0 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -61  0xffffffc3 (PmmC func) args[1] r=0  (not used)
gfx_ChangeColour                     -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -51  0xffffffcd (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -52  0xffffffcc (PmmC func) args[4] r=0  (not used)
gfx_Clipping                        -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -65  0xffffffbf (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -41  0xffffffd7 (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -156  0xffffff64 (PmmC func) args[1] r=0  (not used)
gfx_Contrast                        -154  0xffffff66 (PmmC func) args[1] r=0  (not used)
gfx_Dot                              -60  0xffffffc4 (PmmC func) args[0] r=0  (not used)
gfx_FocusWindow                      -67  0xffffffbd (PmmC func) args[0] r=1  (not used)
gfx_FrameDelay                      -151  0xffffff69 (PmmC func) args[1] r=0  (not used)
gfx_GetPixel                         -54  0xffffffca (PmmC func) args[2] r=1  (not used)
gfx_Hline                            -47  0xffffffd1 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -62  0xffffffc2 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -63  0xffffffc1 (PmmC func) args[0] r=1  (not used)
GFX_LEFT                              96  0x00000060 (const dword)  (not used)
gfx_Line                             -46  0xffffffd2 (PmmC func) args[5] r=0  (not used)
GFX_LINE_PATTERN                      91  0x0000005b (const dword)  (not used)
gfx_LinePattern                     -155  0xffffff65 (PmmC func) args[1] r=0  (not used)
gfx_LineRel                          -45  0xffffffd3 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -44  0xffffffd4 (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -43  0xffffffd5 (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -42  0xffffffd6 (PmmC func) args[2] r=0  (not used)
GFX_OBJECT_COLOUR                     87  0x00000057 (const dword)  (not used)
gfx_ObjectColour                    -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
gfx_Orbit                            -57  0xffffffc7 (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -56  0xffffffc8 (PmmC func) args[2] r=0  (not used)
GFX_OUTLINE_COLOUR                    90  0x0000005a (const dword)  (not used)
gfx_OutlineColour                   -153  0xffffff67 (PmmC func) args[1] r=0  (not used)
gfx_PenSize                         -145  0xffffff6f (PmmC func) args[1] r=0  (not used)
gfx_Polygon                          -59  0xffffffc5 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -58  0xffffffc6 (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -53  0xffffffcb (PmmC func) args[3] r=0  (not used)
gfx_Rectangle                        -49  0xffffffcf (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -50  0xffffffce (PmmC func) args[5] r=0  (not used)
GFX_RIGHT                             98  0x00000062 (const dword)  (not used)
GFX_SCREENMODE                       161  0x000000a1 (const dword)  (not used)
gfx_ScreenMode                      -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
gfx_Set                              -40  0xffffffd8 (PmmC func) args[2] r=0  (not used)
gfx_SetClipRegion                    -68  0xffffffbc (PmmC func) args[0] r=1  (not used)
GFX_STRINGMETRIX                     122  0x0000007a (const dword)  (not used)
GFX_TEMPSTORE1                       123  0x0000007b (const dword)  (not used)
GFX_TEXT_BGCOLOUR                     89  0x00000059 (const dword)  (not used)
GFX_TEXT_COLOUR                       88  0x00000058 (const dword)  (not used)
GFX_TOP                               97  0x00000061 (const dword)  (not used)
gfx_Tranparency                     -150  0xffffff6a (PmmC func) args[1] r=0  (not used)
gfx_TranparentColour                -149  0xffffff6b (PmmC func) args[1] r=0  (not used)
GFX_TRANSPARENTCOLOUR                121  0x00000079 (const dword)  (not used)
gfx_Triangle                         -55  0xffffffc9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -48  0xffffffd0 (PmmC func) args[4] r=1  (not used)
GFX_X1                               100  0x00000064 (const dword)  (not used)
GFX_X2                               102  0x00000066 (const dword)  (not used)
GFX_X_ORG                            104  0x00000068 (const dword)  (not used)
GFX_XMAX                             159  0x0000009f (const dword)  (not used)
GFX_Y1                               101  0x00000065 (const dword)  (not used)
GFX_Y2                               103  0x00000067 (const dword)  (not used)
GFX_Y_ORG                            105  0x00000069 (const dword)  (not used)
GFX_YMAX                             160  0x000000a0 (const dword)  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDELOX                               1  0x00000001 (const dword)  (usage 3)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
iChargeH                               0  0x00000000 (const dword)  (usage 3)
iChargeL                            7680  0x00001e00 (const dword)  (usage 3)
iCPUH                                  0  0x00000000 (const dword)  (usage 3)
iCPUL                                  0  0x00000000 (const dword)  (usage 3)
iCustomdigits1H                       27  0x0000001b (const dword)  (usage 3)
iCustomdigits1L                    48640  0x0000be00 (const dword)  (usage 3)
iCustomdigits2H                       27  0x0000001b (const dword)  (usage 3)
iCustomdigits2L                    52736  0x0000ce00 (const dword)  (usage 3)
iiCustomdigits1H                      27  0x0000001b (const dword)  (usage 3)
iiCustomdigits1L                   49664  0x0000c200 (const dword)  (usage 3)
iiCustomdigits2H                      27  0x0000001b (const dword)  (usage 3)
iiCustomdigits2L                   53760  0x0000d200 (const dword)  (usage 3)
IMAGE_DELAY                          138  0x0000008a (const dword)  (not used)
IMAGE_HEIGHT                         137  0x00000089 (const dword)  (not used)
IMAGE_MODE                           139  0x0000008b (const dword)  (not used)
IMAGE_WIDTH                          136  0x00000088 (const dword)  (not used)
IMG_FRAME_COUNT                       93  0x0000005d (const dword)  (not used)
IMG_PIXEL_COUNT                       92  0x0000005c (const dword)  (not used)
iMotorsH                               0  0x00000000 (const dword)  (usage 3)
iMotorsL                            3584  0x00000e00 (const dword)  (usage 3)
INCVAL                               118  0x00000076 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INIT_TABLE_16BIT_DUMMY_READ          251  0x000000fb (const dword)  (not used)
INIT_TABLE_16BIT_INDEX_REG_MODE      253  0x000000fd (const dword)  (not used)
INIT_TABLE_8BIT_INDEX_REG_MODE       252  0x000000fc (const dword)  (not used)
INIT_TABLE_DELAY                     254  0x000000fe (const dword)  (not used)
INIT_TABLE_END                       255  0x000000ff (const dword)  (not used)
INIT_TABLE_LANDSCAPE                 249  0x000000f9 (const dword)  (not used)
INIT_TABLE_LANDSCAPE_R               247  0x000000f7 (const dword)  (not used)
INIT_TABLE_PORTRAIT                  250  0x000000fa (const dword)  (not used)
INIT_TABLE_PORTRAIT_R                248  0x000000f8 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
Inputs                                 0  0x00000000 (const dword)  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1                                    0  0x00000000 (const dword)  (not used)
IO2                                    1  0x00000001 (const dword)  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -122  0xffffff86 (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
joystick                             -39  0xffffffd9 (PmmC func) args[0] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
ledDigitsDisplay                     312  0x00000138 (User func) args[9] r=0  (usage 6)
ledDigitsDisplayD                 UNRESOLVED (User func) args[9] r=0  (not used)
ledDigitsDisplayL                 UNRESOLVED (User func) args[9] r=0  (not used)
ledDigitsDisplayR                 UNRESOLVED (User func) args[9] r=0  (not used)
LEFT                                   2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          10  0x0000000a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                  38  0x00000026 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -20  0xffffffec (PmmC func) args[2] r=1  (not used)
MDA                                65296  0x0000ff10 (const dword)  (not used)
MEDIA                                  7  0x00000007 (const dword)  (not used)
MEDIA_ADDR_HI                        109  0x0000006d (const dword)  (not used)
MEDIA_ADDR_LO                        108  0x0000006c (const dword)  (not used)
media_Flush                          -78  0xffffffb2 (PmmC func) args[0] r=1  (not used)
MEDIA_HEAD                            94  0x0000005e (const dword)  (not used)
media_Image                          -77  0xffffffb3 (PmmC func) args[2] r=0  (usage 6)
media_Init                           -79  0xffffffb1 (PmmC func) args[0] r=1  (usage 3)
media_ReadByte                       -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
media_ReadWord                       -74  0xffffffb6 (PmmC func) args[0] r=1  (not used)
media_SetAdd                         -71  0xffffffb9 (PmmC func) args[2] r=0  (usage 24)
media_SetSector                      -72  0xffffffb8 (PmmC func) args[2] r=0  (not used)
media_Video                          -69  0xffffffbb (PmmC func) args[2] r=0  (not used)
media_VideoFrame                     -70  0xffffffba (PmmC func) args[3] r=0  (usage 18)
media_WriteByte                      -75  0xffffffb5 (PmmC func) args[1] r=1  (not used)
media_WriteWord                      -76  0xffffffb4 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
MIDI                                  95  0x0000005f (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -19  0xffffffed (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
OBJECT_COLOUR                          2  0x00000002 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
ONEWIRE                                4  0x00000004 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                         8  0x00000008 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -26  0xffffffe6 (PmmC func) args[0] r=1  (not used)
OW_Read                              -35  0xffffffdd (PmmC func) args[0] r=1  (not used)
OW_Read9                             -36  0xffffffdc (PmmC func) args[0] r=1  (not used)
OW_Reset                             -34  0xffffffde (PmmC func) args[0] r=1  (not used)
OW_Write                             -37  0xffffffdb (PmmC func) args[1] r=0  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 9)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekB                                -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                               0  0x00000000 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -31  0xffffffe1 (PmmC func) args[1] r=0  (not used)
pin_LO                               -32  0xffffffe0 (PmmC func) args[1] r=0  (not used)
pin_Read                             -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
pin_Set                              -30  0xffffffe2 (PmmC func) args[2] r=0  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeB                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
pokeW                                -13  0xfffffff3 (PmmC func) args[2] r=0  (not used)
pop                                 -117  0xffffff8b (PmmC func) args[0] r=1  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
push                                -119  0xffffff89 (PmmC func) args[1] r=1  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 3)
RAND                                 -24  0xffffffe8 (PmmC func) args[0] r=1  (not used)
RANDOM_HI                            107  0x0000006b (const dword)  (not used)
RANDOM_LO                            106  0x0000006a (const dword)  (not used)
READ_GRAM_REG                        135  0x00000087 (const dword)  (not used)
RED                                63488  0x0000f800 (const dword)  (not used)
RELEASED                               0  0x00000000 (const dword)  (not used)
RIGHT                                  4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                            7  0x00000007 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SECTOR_ADDR_HI                       111  0x0000006f (const dword)  (not used)
SECTOR_ADDR_LO                       110  0x0000006e (const dword)  (not used)
SEED                                 -25  0xffffffe7 (PmmC func) args[1] r=0  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
setsp                               -115  0xffffff8d (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -22  0xffffffea (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  5  0x00000005 (const dword)  (not used)
spi_Disable                         -110  0xffffff92 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -107  0xffffff95 (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -108  0xffffff94 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -109  0xffffff93 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
strheight                           -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
strlen                              -123  0xffffff85 (PmmC func) args[1] r=1  (not used)
strwidth                            -126  0xffffff82 (PmmC func) args[1] r=1  (not used)
SWAP                                 -21  0xffffffeb (PmmC func) args[2] r=0  (not used)
SYS_FLAGS1                           126  0x0000007e (const dword)  (not used)
SYS_FLAGS2                           127  0x0000007f (const dword)  (not used)
SYS_OSTREAM                           95  0x0000005f (const dword)  (not used)
SYS_X_MAX                            132  0x00000084 (const dword)  (not used)
SYS_Y_MAX                            133  0x00000085 (const dword)  (not used)
SYSTEM                                 0  0x00000000 (const dword)  (not used)
SYSTEM_TIMER_HI                      113  0x00000071 (const dword)  (not used)
SYSTEM_TIMER_LO                      112  0x00000070 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEMP_MEDIA_ADDRHI                    120  0x00000078 (const dword)  (not used)
TEMP_MEDIA_ADDRLO                    119  0x00000077 (const dword)  (not used)
TEXT                               65288  0x0000ff08 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_DELAY                           156  0x0000009c (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                          155  0x0000009b (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_X_GAP                           157  0x0000009d (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XMAG                            153  0x00000099 (const dword)  (not used)
TEXT_Y_GAP                           158  0x0000009e (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YMAG                            154  0x0000009a (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                               114  0x00000072 (const dword)  (not used)
TIMER1                               115  0x00000073 (const dword)  (not used)
TIMER2                               116  0x00000074 (const dword)  (not used)
TIMER3                               117  0x00000075 (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                           5  0x00000005 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                     4  0x00000004 (const dword)  (not used)
TRUE                                   1  0x00000001 (const dword)  (not used)
tune_Continue                        -82  0xffffffae (PmmC func) args[0] r=0  (not used)
tune_End                             -84  0xffffffac (PmmC func) args[0] r=0  (not used)
tune_Pause                           -81  0xffffffaf (PmmC func) args[0] r=0  (not used)
tune_Play                            -80  0xffffffb0 (PmmC func) args[1] r=0  (not used)
tune_Playing                         -85  0xffffffab (PmmC func) args[0] r=1  (not used)
tune_Stop                            -83  0xffffffad (PmmC func) args[0] r=0  (not used)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Attributes                      -142  0xffffff72 (PmmC func) args[1] r=0  (not used)
txt_BGcolour                        -130  0xffffff7e (PmmC func) args[1] r=0  (not used)
txt_Bold                            -138  0xffffff76 (PmmC func) args[1] r=0  (not used)
txt_Delay                           -136  0xffffff78 (PmmC func) args[1] r=0  (not used)
txt_FGcolour                        -129  0xffffff7f (PmmC func) args[1] r=0  (not used)
txt_FontID                          -131  0xffffff7d (PmmC func) args[1] r=0  (not used)
txt_Height                          -133  0xffffff7b (PmmC func) args[1] r=0  (not used)
txt_Inverse                         -140  0xffffff74 (PmmC func) args[1] r=0  (not used)
txt_Italic                          -139  0xffffff75 (PmmC func) args[1] r=0  (not used)
txt_MoveCursor                       -28  0xffffffe4 (PmmC func) args[2] r=0  (not used)
txt_Opacity                         -137  0xffffff77 (PmmC func) args[1] r=0  (not used)
txt_Set                              -29  0xffffffe3 (PmmC func) args[2] r=0  (not used)
txt_Underline                       -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
txt_Width                           -132  0xffffff7c (PmmC func) args[1] r=0  (not used)
txt_Xgap                            -134  0xffffff7a (PmmC func) args[1] r=0  (not used)
txt_Ygap                            -135  0xffffff79 (PmmC func) args[1] r=0  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
USR_SP                               128  0x00000080 (const dword)  (not used)
USRSTACK                             384  0x00000180 (const dword)  (not used)
USRVARS                              129  0x00000081 (const dword)  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
VM_COLOUR                             84  0x00000054 (const dword)  (not used)
VM_OVERFLOW                           83  0x00000053 (const dword)  (not used)
VM_RETVAL                             85  0x00000055 (const dword)  (not used)
VX1                                  128  0x00000080 (const dword)  (not used)
VX2                                  130  0x00000082 (const dword)  (not used)
VY1                                  129  0x00000081 (const dword)  (not used)
VY2                                  131  0x00000083 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
WRITE_GRAM_REG                       134  0x00000086 (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
